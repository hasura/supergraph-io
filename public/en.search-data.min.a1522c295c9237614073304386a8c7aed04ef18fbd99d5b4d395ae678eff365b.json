[{"id":0,"href":"/api-composition/","title":"API Composition","section":"My New Hugo Site","content":" API Composition: API Integration, Aggregation \u0026amp; Orchestration # We use the term API composition to encompass three main aspects of working with multiple API endpoints: integration, orchestration and aggregation.\nA key driver for the Supergraph is the need for API composition. GraphQL (monolithic or federated) is a special case of this need.\nWhile domain owners (producers) are owners of a domain API, in a multi-consumer \u0026amp; multi-producer scenario, API consumers often also need specialized APIs that are optimized for their use-cases.\nThis creates a tension between \u0026ldquo;domain driven\u0026rdquo; API design and ownership and \u0026ldquo;consumer driven\u0026rdquo; API design.\nDesign \u0026amp; Ownership Benefits Challenges Domain driven Consistent, standardized API for multiple consumers Not optimized for consumer needs Consumer driven Optimized for single consumer and can incorporate consumer specific business logic Hard to standardize and needs to be purpose-built for every consumer A supergraph allows both these API design and ownership models to co-exist. A supergraph platform brings in domain APIs via its subgraph connectors and provides a self-serve API orchestration \u0026amp; aggregation layer across the various domains. This allows domain owners to design and evolve their domain API, and other supergraph stakeholders to aggregate APIs on-demand and add custom orchestration workflows.\nA supergraph platform solves the following 3 API composition problems:\nIntegration Aggregation Orchestration Integration # Given that domains and domain APIs exist, API integration remains challenging for API consumers for the following reasons:\nThe API output format or protocol is not ideal or optimal for a consumer The API does not have a typed schema and/or does not provide a SDK experience for the consumer The API\u0026rsquo;s documentation is missing or out of date The API does not have standardized conventions or follow a consistent design A supergraph provides a systematic way to address these challenges because it provides a common semantic layer and registry for the underlying domains and their APIs. A well setup supergraph platform provides out of the box solutions for the challenges mentioned above.\nAggregation (or batching) # API consumers often need to fetch data from multiple API endpoints. API aggregation or batching, performed closer to the domains can prevent excessive data transfer and prevent network round trips.\nAPI aggregation is challenging because:\nExplosive creation of new aggregation API endpoints: Different consumers have different needs and their needs evolve rapidly in a high-velocity environment Fuzzy ownership: Domain APIs are owned and designed by domain owners but often it is not clear who builds, designs and operates API endpoints that aggregate data across these endpoints A supergraph provides a self-service model for API aggregation and batching by modelling the underlying domains as a \u0026ldquo;graph\u0026rdquo; and then allowing API consumers to fetch whatever slice of data they need from the on-demand without requiring the development and maintenance of new aggregate endpoints.\nA well setup supergraph platform provides a high level of composability that makes different types of API aggregation possible on demand. Eg:\nJoins: Fetch data from A and related data B Nested filters: Fetch data from A, filtered by a property value of its related data B. Orchestration # API consumers often need to create reliable workflows that require sequencing multiple API calls interspersed with business logic. Even if the underlying domain APIs exist, API orchestration is challenging because it is the part of the API that is consumer defined and potentially spans multiple domains.\nThis makes it challenging to create a unified technology approach and identify owners to build and operate these workflows.\nRelated: Sagas, Distributed transactions, state machines.\nA supergraph platform should provide a clear operating model and technology best practices to manage API orchestration, beyond simple aggregation/batching use-cases.\nAPI composition checklist for a supergraph platform # Federated GraphQL anti-patterns # Building a federated GraphQL API with a supergraph is a strategic decision. When the key desired benefit of GraphQL is to solve an API composition problem on top of existing domains, then the key expected ROI is to improve API integration, aggregation and orchestration. In this case, the following anti-patterns should be avoided. Building a federated GraphQL API with a supergraph is a strategic decision and the wrong choice can create thousands of person-hours of technical debt and legacy that become hard to unwind.\n❌ Pure schema-driven design: The situation: A schema driven in GraphQL is the approach of first building a schema that is entirely based on what consumers need. The problem: While this approach is important for the parts of the API that require API aggregation and custom API orchestration workflows, this approach negates the effort that has gone into and the effort that will continue to go into maintaining domain APIs. Symptoms: API producers are not willing to own their subgraphs and find it tedious to maintain another subgraph API. Additional subgraph teams and developers are required to maintain domain subgraphs. The solution: Generating parts of the supergraph from the domain, and building parts of the supergraph based on consumer needs is the ideal approach. ❌ Forcing subgraph owners to own inter-subgraph relationships: The situation: Relationships between subgraphs can only be specified by subgraph owners. The problem: While this approach allows subgraph owners to extend and connect their subgraphs to other subgraphs, it requires domain owners (subgraph owners) to understand other subgraphs. Symptoms: Disconnected supergraphs. Inefficient query execution plans if relationships are hard to implement in some directions. API consumers who are frustrated at not being able to participate in creating inter-subgraph relationships. The solution: In addition to allowing subgraph owners to create inter-subgraph relationships, allow creation of relationships in the supergraph engine outside the subgraphs as well. ❌ Requiring an additional API registry to create custom resolvers (eg: federated mutations): The situation: Mutations can only originate from a domain subgraph. The problem: Supergraph stakeholders are forced to create a new subgraph that directly connects to underlying domains. This requires stakeholders to refer to another API registry to understand how to connect to the underlying subgraph domains (eg: database, REST). Symptoms: API consumers are frustrated at not being able to easily create custom resolvers that represent some unique business logic \u0026amp; workflow for their specific need. Lack of an operating model around federating mutations, or API sagas or distributed transactions. The solution: The supergraph platform should provide a way for supergraph stakeholders to author custom API workflows interspersed with business logic without having to refer to APIs outside of the supergraph. "},{"id":1,"href":"/faq/","title":"Faq","section":"My New Hugo Site","content":" FAQ # Supergraph vs alternative approaches # "},{"id":2,"href":"/full-reference-graphql-schema/","title":"Full Reference Graphql Schema","section":"My New Hugo Site","content":" schema { query: query_root subscription: subscription_root } \u0026#34;\u0026#34;\u0026#34; Boolean expression to compare columns of type \u0026#34;Int\u0026#34;. All fields are combined with logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input Int_comparison_exp { _eq: Int _gt: Int _gte: Int _in: [Int!] _is_null: Boolean _lt: Int _lte: Int _neq: Int _nin: [Int!] } \u0026#34;\u0026#34;\u0026#34; Boolean expression to compare columns of type \u0026#34;String\u0026#34;. All fields are combined with logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input String_comparison_exp { _eq: String _gt: String _gte: String \u0026#34;\u0026#34;\u0026#34;does the column match the given case-insensitive pattern\u0026#34;\u0026#34;\u0026#34; _ilike: String _in: [String!] \u0026#34;\u0026#34;\u0026#34; does the column match the given POSIX regular expression, case insensitive \u0026#34;\u0026#34;\u0026#34; _iregex: String _is_null: Boolean \u0026#34;\u0026#34;\u0026#34;does the column match the given pattern\u0026#34;\u0026#34;\u0026#34; _like: String _lt: String _lte: String _neq: String \u0026#34;\u0026#34;\u0026#34;does the column NOT match the given case-insensitive pattern\u0026#34;\u0026#34;\u0026#34; _nilike: String _nin: [String!] \u0026#34;\u0026#34;\u0026#34; does the column NOT match the given POSIX regular expression, case insensitive \u0026#34;\u0026#34;\u0026#34; _niregex: String \u0026#34;\u0026#34;\u0026#34;does the column NOT match the given pattern\u0026#34;\u0026#34;\u0026#34; _nlike: String \u0026#34;\u0026#34;\u0026#34; does the column NOT match the given POSIX regular expression, case sensitive \u0026#34;\u0026#34;\u0026#34; _nregex: String \u0026#34;\u0026#34;\u0026#34;does the column NOT match the given SQL regular expression\u0026#34;\u0026#34;\u0026#34; _nsimilar: String \u0026#34;\u0026#34;\u0026#34; does the column match the given POSIX regular expression, case sensitive \u0026#34;\u0026#34;\u0026#34; _regex: String \u0026#34;\u0026#34;\u0026#34;does the column match the given SQL regular expression\u0026#34;\u0026#34;\u0026#34; _similar: String } \u0026#34;\u0026#34;\u0026#34; columns and relationships of \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; type article { \u0026#34;\u0026#34;\u0026#34;An object relationship\u0026#34;\u0026#34;\u0026#34; author: author! author_id: Int! id: Int! publishDate: date \u0026#34;\u0026#34;\u0026#34;An array relationship\u0026#34;\u0026#34;\u0026#34; ratings( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [rating_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [rating_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): [rating!]! \u0026#34;\u0026#34;\u0026#34;An aggregate relationship\u0026#34;\u0026#34;\u0026#34; ratings_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [rating_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [rating_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): rating_aggregate! title: String! } \u0026#34;\u0026#34;\u0026#34; aggregated selection of \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; type article_aggregate { aggregate: article_aggregate_fields nodes: [article!]! } input article_aggregate_bool_exp { count: article_aggregate_bool_exp_count } input article_aggregate_bool_exp_count { arguments: [article_select_column!] distinct: Boolean filter: article_bool_exp predicate: Int_comparison_exp! } \u0026#34;\u0026#34;\u0026#34; aggregate fields of \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; type article_aggregate_fields { avg: article_avg_fields count(columns: [article_select_column!], distinct: Boolean): Int! max: article_max_fields min: article_min_fields stddev: article_stddev_fields stddev_pop: article_stddev_pop_fields stddev_samp: article_stddev_samp_fields sum: article_sum_fields var_pop: article_var_pop_fields var_samp: article_var_samp_fields variance: article_variance_fields } \u0026#34;\u0026#34;\u0026#34; order by aggregate values of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_aggregate_order_by { avg: article_avg_order_by count: order_by max: article_max_order_by min: article_min_order_by stddev: article_stddev_order_by stddev_pop: article_stddev_pop_order_by stddev_samp: article_stddev_samp_order_by sum: article_sum_order_by var_pop: article_var_pop_order_by var_samp: article_var_samp_order_by variance: article_variance_order_by } \u0026#34;\u0026#34;\u0026#34;aggregate avg on columns\u0026#34;\u0026#34;\u0026#34; type article_avg_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by avg() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_avg_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34; Boolean expression to filter rows from the table \u0026#34;article\u0026#34;. All fields are combined with a logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input article_bool_exp { _and: [article_bool_exp!] _not: article_bool_exp _or: [article_bool_exp!] author: author_bool_exp author_id: Int_comparison_exp id: Int_comparison_exp publishDate: date_comparison_exp ratings: rating_bool_exp ratings_aggregate: rating_aggregate_bool_exp title: String_comparison_exp } \u0026#34;\u0026#34;\u0026#34;aggregate max on columns\u0026#34;\u0026#34;\u0026#34; type article_max_fields { author_id: Int id: Int publishDate: date title: String } \u0026#34;\u0026#34;\u0026#34; order by max() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_max_order_by { author_id: order_by id: order_by publishDate: order_by title: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate min on columns\u0026#34;\u0026#34;\u0026#34; type article_min_fields { author_id: Int id: Int publishDate: date title: String } \u0026#34;\u0026#34;\u0026#34; order by min() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_min_order_by { author_id: order_by id: order_by publishDate: order_by title: order_by } \u0026#34;\u0026#34;\u0026#34;Ordering options when selecting data from \u0026#34;article\u0026#34;.\u0026#34;\u0026#34;\u0026#34; input article_order_by { author: author_order_by author_id: order_by id: order_by publishDate: order_by ratings_aggregate: rating_aggregate_order_by title: order_by } \u0026#34;\u0026#34;\u0026#34; select columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; enum article_select_column { \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; author_id \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; id \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; publishDate \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; title } \u0026#34;\u0026#34;\u0026#34;aggregate stddev on columns\u0026#34;\u0026#34;\u0026#34; type article_stddev_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by stddev() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_stddev_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate stddev_pop on columns\u0026#34;\u0026#34;\u0026#34; type article_stddev_pop_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by stddev_pop() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_stddev_pop_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate stddev_samp on columns\u0026#34;\u0026#34;\u0026#34; type article_stddev_samp_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by stddev_samp() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_stddev_samp_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34; Streaming cursor of the table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_stream_cursor_input { \u0026#34;\u0026#34;\u0026#34;Stream column input with initial value\u0026#34;\u0026#34;\u0026#34; initial_value: article_stream_cursor_value_input! \u0026#34;\u0026#34;\u0026#34;cursor ordering\u0026#34;\u0026#34;\u0026#34; ordering: cursor_ordering } \u0026#34;\u0026#34;\u0026#34;Initial value of the column from where the streaming should start\u0026#34;\u0026#34;\u0026#34; input article_stream_cursor_value_input { author_id: Int id: Int publishDate: date title: String } \u0026#34;\u0026#34;\u0026#34;aggregate sum on columns\u0026#34;\u0026#34;\u0026#34; type article_sum_fields { author_id: Int id: Int } \u0026#34;\u0026#34;\u0026#34; order by sum() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_sum_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate var_pop on columns\u0026#34;\u0026#34;\u0026#34; type article_var_pop_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by var_pop() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_var_pop_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate var_samp on columns\u0026#34;\u0026#34;\u0026#34; type article_var_samp_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by var_samp() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_var_samp_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate variance on columns\u0026#34;\u0026#34;\u0026#34; type article_variance_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by variance() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_variance_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34; columns and relationships of \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; type author { age: numeric \u0026#34;\u0026#34;\u0026#34;An array relationship\u0026#34;\u0026#34;\u0026#34; articles( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [article_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [article_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): [article!]! \u0026#34;\u0026#34;\u0026#34;An aggregate relationship\u0026#34;\u0026#34;\u0026#34; articles_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [article_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [article_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): article_aggregate! id: Int! name: String! } \u0026#34;\u0026#34;\u0026#34; aggregated selection of \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; type author_aggregate { aggregate: author_aggregate_fields nodes: [author!]! } \u0026#34;\u0026#34;\u0026#34; aggregate fields of \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; type author_aggregate_fields { avg: author_avg_fields count(columns: [author_select_column!], distinct: Boolean): Int! max: author_max_fields min: author_min_fields stddev: author_stddev_fields stddev_pop: author_stddev_pop_fields stddev_samp: author_stddev_samp_fields sum: author_sum_fields var_pop: author_var_pop_fields var_samp: author_var_samp_fields variance: author_variance_fields } \u0026#34;\u0026#34;\u0026#34;aggregate avg on columns\u0026#34;\u0026#34;\u0026#34; type author_avg_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34; Boolean expression to filter rows from the table \u0026#34;author\u0026#34;. All fields are combined with a logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input author_bool_exp { _and: [author_bool_exp!] _not: author_bool_exp _or: [author_bool_exp!] age: numeric_comparison_exp articles: article_bool_exp articles_aggregate: article_aggregate_bool_exp id: Int_comparison_exp name: String_comparison_exp } \u0026#34;\u0026#34;\u0026#34;aggregate max on columns\u0026#34;\u0026#34;\u0026#34; type author_max_fields { age: numeric id: Int name: String } \u0026#34;\u0026#34;\u0026#34;aggregate min on columns\u0026#34;\u0026#34;\u0026#34; type author_min_fields { age: numeric id: Int name: String } \u0026#34;\u0026#34;\u0026#34;Ordering options when selecting data from \u0026#34;author\u0026#34;.\u0026#34;\u0026#34;\u0026#34; input author_order_by { age: order_by articles_aggregate: article_aggregate_order_by id: order_by name: order_by } \u0026#34;\u0026#34;\u0026#34; select columns of table \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; enum author_select_column { \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; age \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; id \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; name } \u0026#34;\u0026#34;\u0026#34;aggregate stddev on columns\u0026#34;\u0026#34;\u0026#34; type author_stddev_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34;aggregate stddev_pop on columns\u0026#34;\u0026#34;\u0026#34; type author_stddev_pop_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34;aggregate stddev_samp on columns\u0026#34;\u0026#34;\u0026#34; type author_stddev_samp_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34; Streaming cursor of the table \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; input author_stream_cursor_input { \u0026#34;\u0026#34;\u0026#34;Stream column input with initial value\u0026#34;\u0026#34;\u0026#34; initial_value: author_stream_cursor_value_input! \u0026#34;\u0026#34;\u0026#34;cursor ordering\u0026#34;\u0026#34;\u0026#34; ordering: cursor_ordering } \u0026#34;\u0026#34;\u0026#34;Initial value of the column from where the streaming should start\u0026#34;\u0026#34;\u0026#34; input author_stream_cursor_value_input { age: numeric id: Int name: String } \u0026#34;\u0026#34;\u0026#34;aggregate sum on columns\u0026#34;\u0026#34;\u0026#34; type author_sum_fields { age: numeric id: Int } \u0026#34;\u0026#34;\u0026#34;aggregate var_pop on columns\u0026#34;\u0026#34;\u0026#34; type author_var_pop_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34;aggregate var_samp on columns\u0026#34;\u0026#34;\u0026#34; type author_var_samp_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34;aggregate variance on columns\u0026#34;\u0026#34;\u0026#34; type author_variance_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34;ordering argument of a cursor\u0026#34;\u0026#34;\u0026#34; enum cursor_ordering { \u0026#34;\u0026#34;\u0026#34;ascending ordering of the cursor\u0026#34;\u0026#34;\u0026#34; ASC \u0026#34;\u0026#34;\u0026#34;descending ordering of the cursor\u0026#34;\u0026#34;\u0026#34; DESC } scalar date \u0026#34;\u0026#34;\u0026#34; Boolean expression to compare columns of type \u0026#34;date\u0026#34;. All fields are combined with logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input date_comparison_exp { _eq: date _gt: date _gte: date _in: [date!] _is_null: Boolean _lt: date _lte: date _neq: date _nin: [date!] } scalar numeric \u0026#34;\u0026#34;\u0026#34; Boolean expression to compare columns of type \u0026#34;numeric\u0026#34;. All fields are combined with logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input numeric_comparison_exp { _eq: numeric _gt: numeric _gte: numeric _in: [numeric!] _is_null: Boolean _lt: numeric _lte: numeric _neq: numeric _nin: [numeric!] } \u0026#34;\u0026#34;\u0026#34;column ordering options\u0026#34;\u0026#34;\u0026#34; enum order_by { \u0026#34;\u0026#34;\u0026#34;in ascending order, nulls last\u0026#34;\u0026#34;\u0026#34; asc \u0026#34;\u0026#34;\u0026#34;in ascending order, nulls first\u0026#34;\u0026#34;\u0026#34; asc_nulls_first \u0026#34;\u0026#34;\u0026#34;in ascending order, nulls last\u0026#34;\u0026#34;\u0026#34; asc_nulls_last \u0026#34;\u0026#34;\u0026#34;in descending order, nulls first\u0026#34;\u0026#34;\u0026#34; desc \u0026#34;\u0026#34;\u0026#34;in descending order, nulls first\u0026#34;\u0026#34;\u0026#34; desc_nulls_first \u0026#34;\u0026#34;\u0026#34;in descending order, nulls last\u0026#34;\u0026#34;\u0026#34; desc_nulls_last } type query_root { \u0026#34;\u0026#34;\u0026#34; fetch data from the table: \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; article( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [article_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [article_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): [article!]! \u0026#34;\u0026#34;\u0026#34; fetch aggregated fields from the table: \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; article_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [article_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [article_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): article_aggregate! \u0026#34;\u0026#34;\u0026#34;fetch data from the table: \u0026#34;article\u0026#34; using primary key columns\u0026#34;\u0026#34;\u0026#34; article_by_pk(id: Int!): article \u0026#34;\u0026#34;\u0026#34; fetch data from the table: \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; author( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): [author!]! \u0026#34;\u0026#34;\u0026#34; fetch aggregated fields from the table: \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; author_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): author_aggregate! \u0026#34;\u0026#34;\u0026#34;fetch data from the table: \u0026#34;author\u0026#34; using primary key columns\u0026#34;\u0026#34;\u0026#34; author_by_pk(id: Int!): author \u0026#34;\u0026#34;\u0026#34; fetch data from the table: \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; rating( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [rating_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [rating_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): [rating!]! \u0026#34;\u0026#34;\u0026#34; fetch aggregated fields from the table: \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; rating_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [rating_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [rating_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): rating_aggregate! \u0026#34;\u0026#34;\u0026#34;fetch data from the table: \u0026#34;rating\u0026#34; using primary key columns\u0026#34;\u0026#34;\u0026#34; rating_by_pk(id: Int!): rating \u0026#34;\u0026#34;\u0026#34; execute function \u0026#34;search_authors\u0026#34; which returns \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; search_authors( \u0026#34;\u0026#34;\u0026#34; input parameters for function \u0026#34;search_authors\u0026#34; \u0026#34;\u0026#34;\u0026#34; args: search_authors_args! \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): [author!]! \u0026#34;\u0026#34;\u0026#34; execute function \u0026#34;search_authors\u0026#34; and query aggregates on result of table type \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; search_authors_aggregate( \u0026#34;\u0026#34;\u0026#34; input parameters for function \u0026#34;search_authors_aggregate\u0026#34; \u0026#34;\u0026#34;\u0026#34; args: search_authors_args! \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): author_aggregate! } \u0026#34;\u0026#34;\u0026#34; columns and relationships of \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; type rating { \u0026#34;\u0026#34;\u0026#34;An object relationship\u0026#34;\u0026#34;\u0026#34; article: article! article_id: Int! id: Int! stars: Int! user_id: Int! } \u0026#34;\u0026#34;\u0026#34; aggregated selection of \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; type rating_aggregate { aggregate: rating_aggregate_fields nodes: [rating!]! } input rating_aggregate_bool_exp { count: rating_aggregate_bool_exp_count } input rating_aggregate_bool_exp_count { arguments: [rating_select_column!] distinct: Boolean filter: rating_bool_exp predicate: Int_comparison_exp! } \u0026#34;\u0026#34;\u0026#34; aggregate fields of \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; type rating_aggregate_fields { avg: rating_avg_fields count(columns: [rating_select_column!], distinct: Boolean): Int! max: rating_max_fields min: rating_min_fields stddev: rating_stddev_fields stddev_pop: rating_stddev_pop_fields stddev_samp: rating_stddev_samp_fields sum: rating_sum_fields var_pop: rating_var_pop_fields var_samp: rating_var_samp_fields variance: rating_variance_fields } \u0026#34;\u0026#34;\u0026#34; order by aggregate values of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_aggregate_order_by { avg: rating_avg_order_by count: order_by max: rating_max_order_by min: rating_min_order_by stddev: rating_stddev_order_by stddev_pop: rating_stddev_pop_order_by stddev_samp: rating_stddev_samp_order_by sum: rating_sum_order_by var_pop: rating_var_pop_order_by var_samp: rating_var_samp_order_by variance: rating_variance_order_by } \u0026#34;\u0026#34;\u0026#34;aggregate avg on columns\u0026#34;\u0026#34;\u0026#34; type rating_avg_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by avg() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_avg_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34; Boolean expression to filter rows from the table \u0026#34;rating\u0026#34;. All fields are combined with a logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input rating_bool_exp { _and: [rating_bool_exp!] _not: rating_bool_exp _or: [rating_bool_exp!] article: article_bool_exp article_id: Int_comparison_exp id: Int_comparison_exp stars: Int_comparison_exp user_id: Int_comparison_exp } \u0026#34;\u0026#34;\u0026#34;aggregate max on columns\u0026#34;\u0026#34;\u0026#34; type rating_max_fields { article_id: Int id: Int stars: Int user_id: Int } \u0026#34;\u0026#34;\u0026#34; order by max() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_max_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate min on columns\u0026#34;\u0026#34;\u0026#34; type rating_min_fields { article_id: Int id: Int stars: Int user_id: Int } \u0026#34;\u0026#34;\u0026#34; order by min() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_min_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;Ordering options when selecting data from \u0026#34;rating\u0026#34;.\u0026#34;\u0026#34;\u0026#34; input rating_order_by { article: article_order_by article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34; select columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; enum rating_select_column { \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; article_id \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; id \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; stars \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; user_id } \u0026#34;\u0026#34;\u0026#34;aggregate stddev on columns\u0026#34;\u0026#34;\u0026#34; type rating_stddev_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by stddev() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_stddev_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate stddev_pop on columns\u0026#34;\u0026#34;\u0026#34; type rating_stddev_pop_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by stddev_pop() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_stddev_pop_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate stddev_samp on columns\u0026#34;\u0026#34;\u0026#34; type rating_stddev_samp_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by stddev_samp() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_stddev_samp_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34; Streaming cursor of the table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_stream_cursor_input { \u0026#34;\u0026#34;\u0026#34;Stream column input with initial value\u0026#34;\u0026#34;\u0026#34; initial_value: rating_stream_cursor_value_input! \u0026#34;\u0026#34;\u0026#34;cursor ordering\u0026#34;\u0026#34;\u0026#34; ordering: cursor_ordering } \u0026#34;\u0026#34;\u0026#34;Initial value of the column from where the streaming should start\u0026#34;\u0026#34;\u0026#34; input rating_stream_cursor_value_input { article_id: Int id: Int stars: Int user_id: Int } \u0026#34;\u0026#34;\u0026#34;aggregate sum on columns\u0026#34;\u0026#34;\u0026#34; type rating_sum_fields { article_id: Int id: Int stars: Int user_id: Int } \u0026#34;\u0026#34;\u0026#34; order by sum() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_sum_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate var_pop on columns\u0026#34;\u0026#34;\u0026#34; type rating_var_pop_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by var_pop() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_var_pop_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate var_samp on columns\u0026#34;\u0026#34;\u0026#34; type rating_var_samp_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by var_samp() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_var_samp_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate variance on columns\u0026#34;\u0026#34;\u0026#34; type rating_variance_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by variance() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_variance_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } input search_authors_args { search: String } type subscription_root { \u0026#34;\u0026#34;\u0026#34; fetch data from the table: \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; article( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [article_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [article_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): [article!]! \u0026#34;\u0026#34;\u0026#34; fetch aggregated fields from the table: \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; article_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [article_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [article_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): article_aggregate! \u0026#34;\u0026#34;\u0026#34;fetch data from the table: \u0026#34;article\u0026#34; using primary key columns\u0026#34;\u0026#34;\u0026#34; article_by_pk(id: Int!): article \u0026#34;\u0026#34;\u0026#34; fetch data from the table in a streaming manner: \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; article_stream( \u0026#34;\u0026#34;\u0026#34;maximum number of rows returned in a single batch\u0026#34;\u0026#34;\u0026#34; batch_size: Int! \u0026#34;\u0026#34;\u0026#34;cursor to stream the results returned by the query\u0026#34;\u0026#34;\u0026#34; cursor: [article_stream_cursor_input]! \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): [article!]! \u0026#34;\u0026#34;\u0026#34; fetch data from the table: \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; author( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): [author!]! \u0026#34;\u0026#34;\u0026#34; fetch aggregated fields from the table: \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; author_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): author_aggregate! \u0026#34;\u0026#34;\u0026#34;fetch data from the table: \u0026#34;author\u0026#34; using primary key columns\u0026#34;\u0026#34;\u0026#34; author_by_pk(id: Int!): author \u0026#34;\u0026#34;\u0026#34; fetch data from the table in a streaming manner: \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; author_stream( \u0026#34;\u0026#34;\u0026#34;maximum number of rows returned in a single batch\u0026#34;\u0026#34;\u0026#34; batch_size: Int! \u0026#34;\u0026#34;\u0026#34;cursor to stream the results returned by the query\u0026#34;\u0026#34;\u0026#34; cursor: [author_stream_cursor_input]! \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): [author!]! \u0026#34;\u0026#34;\u0026#34; fetch data from the table: \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; rating( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [rating_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [rating_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): [rating!]! \u0026#34;\u0026#34;\u0026#34; fetch aggregated fields from the table: \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; rating_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [rating_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [rating_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): rating_aggregate! \u0026#34;\u0026#34;\u0026#34;fetch data from the table: \u0026#34;rating\u0026#34; using primary key columns\u0026#34;\u0026#34;\u0026#34; rating_by_pk(id: Int!): rating \u0026#34;\u0026#34;\u0026#34; fetch data from the table in a streaming manner: \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; rating_stream( \u0026#34;\u0026#34;\u0026#34;maximum number of rows returned in a single batch\u0026#34;\u0026#34;\u0026#34; batch_size: Int! \u0026#34;\u0026#34;\u0026#34;cursor to stream the results returned by the query\u0026#34;\u0026#34;\u0026#34; cursor: [rating_stream_cursor_input]! \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): [rating!]! \u0026#34;\u0026#34;\u0026#34; execute function \u0026#34;search_authors\u0026#34; which returns \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; search_authors( \u0026#34;\u0026#34;\u0026#34; input parameters for function \u0026#34;search_authors\u0026#34; \u0026#34;\u0026#34;\u0026#34; args: search_authors_args! \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): [author!]! \u0026#34;\u0026#34;\u0026#34; execute function \u0026#34;search_authors\u0026#34; and query aggregates on result of table type \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; search_authors_aggregate( \u0026#34;\u0026#34;\u0026#34; input parameters for function \u0026#34;search_authors_aggregate\u0026#34; \u0026#34;\u0026#34;\u0026#34; args: search_authors_args! \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): author_aggregate! } "},{"id":3,"href":"/readme/","title":"Readme","section":"My New Hugo Site","content":" The Supergraph Manifesto # Supergraph is an architecture framework that offers reference architectures, design guidelines/principles and an operating model to help multiple teams to collaborate on a self-serve platform for federated data access, API integration/composition or GraphQL APIs. An implementation artifact of the Supergraph architecture is called a supergraph (lowercase s).\nWhen a supergraph is built with a GraphQL federation stack, the engine is often called a gateway or a router and the subgraph connectors are often GraphQL services.\nA supergraph is typically used for the following 3 benefits:\nSelf-serve API composition: A self-serve operating model for API integration, orchestration \u0026amp; aggregation Federated data access layer: A federated data layer that allows realtime access to data sources with cross-domain composability (joins, filtering etc.) Related: Data mesh, data products Incremental monolith decomposition: A stable API that provides a zero-downtime and incremental approach to decomposing monoliths Strategy and Core concepts # A supergraph approach aims to build a flywheel of data access and supply to incrementally improve self-service access to data and APIs.\nI. CONNECT domains # Domain owners (or data owners, or API producers) should be able to seamlessly connect their domains to the platform. A major challenge in building supergraph is the resistance to change by the domain owners. They often oppose having to build, operate and maintain another API layer, such as a GraphQL server that creates another wrapper on their domain. This reluctance and concern is understandable and completely valid and must be systematically addressed by the supergraph platform strategy and the supergraph reference architecture.\nThis has two main implications for the subgraph connector\u0026rsquo;s lifecycle and runtime:\nSubgraph connector CI/CD: As domain owners change their domains, the API contract published via the supergraph engine, must stay in sync with the least amount of overhead for the domain owner. The SDLC, change-management or CI/CD process of the domain owners must involve updating their API contract (eg: versioning), prevent breaking changes and keeping documentation up to date. Subgraph connector performance: The subgraph connector must not reduce performance as compared to what is provided by accessing the underlying domain directly. API performance characteristics as measured by latency, payload size \u0026amp; concurrency. Guaranteeing a smooth CI/CD process and high-performance connectivity gives domain owners confidence that they can connect their domains to the supergraph platform and iterate on changes to their domains fearlessly.\nThis unlocks self-serve connectivity for domain owners.\nII. CONSUME APIs # API consumers should be able to discover and consume APIs in a way that doesn\u0026rsquo;t require manual API integration, aggregation or composition effort as far as possible. API consumers have several common needs when they\u0026rsquo;re dealing with fixed API endpoints or specific data queries:\nfetch different projections of data to prevent over-fetching join data from multiple places to prevent under-fetching filter, paginate, sort and aggregate data from multiple places To provide an API experience that makes the consumption experience truly self-serve, there are two key requirements:\nComposable API design: The API presented by the supergraph engine must allow for on-demand composability. GraphQL is a great API to express composability semantics, but regardless of the API format used, a standardized, composable API design is a critical requirement. API portal: High-quality search, discovery and documentation of both the API and the underlying API models is critical to enable self-serve consumption. The more information that can be made available to API consumers the better. Eg: Data lineage, Authorization policies etc as appropriate. This unlocks self-serve consumption for API consumers\nIII. DISCOVER demand # Understanding how API consumers use their domain and identify their unmet needs is crucial for API producers. This insight allows API producers to enhance their domain. It also helps discover new domain owners to connect their domain into the supergraph.\nThis necessitates 2 key capabilities of the supergraph platform to create a consumer-first, agile culture:\nAPI consumption, API schema \u0026amp; portal analytics: A supergraph is analogous to a marketplace and needs to provide the marketplace owners and producers with insights to help improve the marketplace for the consumers. Ecosystem integrations: The supergraph platform should be able to integrate with existing communication and catalog tools, in particular to help understand unmet demand of API consumers. This closes the loop and allows the supergraph platform to create a virtuous cycle of success for producers and consumers.\nArchitecture guide # CI/CD and build system (control plane) # The control plane of the supergraph is critical to help domain owners connect their domains to the supergraph.\nThere are 3 components in the control plane of the supergraph\nThe domain itself The subgraph The supergraph The control plane should define the following SDLC to help keep the supergraph in sync with the domain as the underlying domain changes.\nDistributed data plane # The supergraph data plane is critical to enable high performance access to upstream domains so that API producers can maintain their domain without hidden future maintenance costs:\nAPI schema design guide # Standardization # A supergraph API schema should create standardized conventions on the following:\n# A standardized way to fetch a list of authors query GetAuthors { authors { id name } } # A specific method to search for authors query findAuthors { search_authors(args: {search: \u0026#34;Einstein\u0026#34;}) { id name } } query articlesThisYear { articles(where: {publishDate: {_gt: \u0026#34;2024-01-01\u0026#34;}}) { id name } } query sortedArticles { article(order_by: {publishDate: desc}) { id title author_id } } query sortedArticlesThirdPage { article(order_by: {publishDate: desc}, offset: 40, limit: 20) { id title author_id } } query authorStatistics { author_aggregate { aggregate { count # basic aggregation support by any model avg { # supported over any numeric fields of a type age } } } } Prior art\nGoogle Cloud API design guide Resource: A resource-oriented API is generally modeled as a resource hierarchy, where each node is either a simple resource or a collection resource Method: Resources are manipulated via a small set of methods Composability # The supergraph API is typically a GraphQL / JSON API. There are varying degrees of composability an API can offer, as listed out in the following table:\nquery authorWithArticles { author { id name articles { id title } } } query recentlyActiveAuthors { author(where: {articles: {publishDate: {_gt: \u0026#34;2024-01-01\u0026#34;}}}) { id name } } query sortedArticles { article(order_by: {author: {name: asc}}) { id title } } query paginatedAuthorsWithSortedPaginatedArticles { author(offset: 10, limit: 20) { id name articles(offset: 0, limit: 25, order_by: {title: asc}) { title publishDate } } } query prolificAuthors { author (limit: 10) { id name articles_aggregate { count } } } These composability attributes are what increase the level of self-serve composition and reduce the need for manual API aggregation and composition.\nMore reading # Use cases Reference API schema FAQ "},{"id":4,"href":"/reference-api-schema/","title":"Reference API Schema","section":"My New Hugo Site","content":"The following is an excerpt from a complete reference GraphQL schema (linked at the end) that:\nis built on 3 data domains author (which includes a function search_author that returns author search results), article and rating implements all standardization attributes (S1-S5) by implementing filtering, sorting, pagination, aggregations for the models\u0026rsquo; collections as well as implementing a command for the search function implements all composability attributes (C1-C5) by leveraging the following relationships between the 3 domains: author \u0026lt;\u0026gt; article have a 1:many relationship article \u0026lt;\u0026gt; rating have a 1:many relationship (many users can leave a rating for the same article) type type_name { field1: scalarType1! field2: scalarType2 } type Author { id: Int! name: String } type field( distinct_on: [field_select_column!] limit: Int offset: Int order_by: [field_order_by!] where: field_bool_exp ): [Type!]! type author( distinct_on: [author_select_column!] limit: Int offset: Int order_by: [author_order_by!] where: author_bool_exp #defined below ): [author!]! type author_bool_exp( #argument type defination _and: [author_bool_exp!] _not: author_bool_exp _or: [author_bool_exp!] id: Int_comparison_exp #defined below name: String_comparison_exp ) type Int_comparison_exp( #argument type defination _eq: Int _gt: Int _gte: Int _in: [Int!] _is_null: Boolean _lt: Int _lte: Int _neq: Int _nin: [Int!] ) query filteredAuthors { author(where: {id: {_gt: 100}}, limit: 10) { id name } } type field_aggregate( distinct_on: [field_select_column!] limit: Int offset: Int order_by: [field_order_by!] where: field_bool_exp ): field_aggregateType! type author_aggregate( distinct_on: [author_select_column!] limit: Int offset: Int order_by: [author_order_by!] where: author_bool_exp ): author_aggregate! #defined below type author_aggregate( #argument type defination aggregate: author_aggregate_fields #defined below nodes: [author!]! ) type author_aggregate_fields( #argument type defination avg: author_avg_fields count(columns: [author_select_column!]distinct: Boolean): Int! max: author_max_fields min: author_min_fields stddev: author_stddev_fields ) query filteredAuthorAggregate { author_aggregate(where: {name: {_like: \u0026#34; Curie\u0026#34;}}) { nodes { id name } aggregate { count } } } type field_by_pk(id_field: scalarType1!): type type author_by_pk(id: Int!): author query author { author_by_pk(id: 10) { id name } } type command_name ( args: command_args! distinct_on: [model_select_column!] limit: Int offset: Int order_by: [field_order_by!] where: field_bool_exp ): [Type!]! type search_authors( args: search_authors_args! distinct_on: [author_select_column!] limit: Int offset: Int order_by: [author_order_by!] where: author_bool_exp ): [author!]! query findAuthors { search_authors(args: {search: \u0026#34;Einstein\u0026#34;}) { id name } } Complete reference GraphQL schema\n"},{"id":5,"href":"/use-cases/","title":"Use Cases","section":"My New Hugo Site","content":" Use Cases # The underlying problem that requires a supergraph: # Consuming data from multiple places requires integration or aggregation work This increases the burden on the producer since it takes time to build and is fragile The problem is combinatorially complex when there are multiple producers and multiple consumers Here are some common scenarios which point to the need of a supergraph: # You\u0026rsquo;re starting to evaluate the need of a federated data access layer API consumers wish they had a monolithic API view of their microservice APIs API consumers want GraphQL, but API producers don\u0026rsquo;t want to maintain GraphQL services You\u0026rsquo;re trying to add API integration or orchestration capabilities to your API gateway You\u0026rsquo;re thinking about API standardization for creating flexible data APIs You want to replace direct database access with APIs You want to deliver data products or a data mesh over an API You want to create a knowledge graph and enable data retrieval for AI applications In all of the situations above, the key problem is the lack of a strategy and an architecture to operationalize the strategy: # API consumers are frustrated by the lack of APIs that are optimized for their specific data retrieval use cases API producers are not willing to take on the burden of maintaining and operationalizing API aggregation and composition problems There is no operating model or ownership model for who should solve the integration problem "}]