<!doctype html><html lang=en-us dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="API Composition: API Integration, Aggregation & Orchestration # We use the term API composition to encompass three main aspects of working with multiple API endpoints: integration, orchestration and aggregation.
A key driver for the Supergraph is the need for API composition. GraphQL (monolithic or federated) is a special case of this need.
While domain owners (producers) are owners of a domain API, in a multi-consumer & multi-producer scenario, API consumers often also need specialized APIs that are optimized for their use-cases."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/api-composition/"><meta property="og:site_name" content="My New Hugo Site"><meta property="og:title" content="My New Hugo Site"><meta property="og:description" content="API Composition: API Integration, Aggregation & Orchestration # We use the term API composition to encompass three main aspects of working with multiple API endpoints: integration, orchestration and aggregation.
A key driver for the Supergraph is the need for API composition. GraphQL (monolithic or federated) is a special case of this need.
While domain owners (producers) are owners of a domain API, in a multi-consumer & multi-producer scenario, API consumers often also need specialized APIs that are optimized for their use-cases."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><title>API Composition | My New Hugo Site</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=http://localhost:1313/api-composition/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.5a50c29a8eb404205798f7f93df478602bcd37e40c7e1cb473b6f89a7001cc8f.js integrity="sha256-WlDCmo60BCBXmPf5PfR4YCvNN+QMfhy0c7b4mnABzI8=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>My New Hugo Site</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>API Composition</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#integration>Integration</a></li><li><a href=#aggregation-or-batching>Aggregation (or batching)</a></li><li><a href=#orchestration>Orchestration</a></li><li><a href=#api-composition-checklist-for-a-supergraph-platform>API composition checklist for a supergraph platform</a></li><li><a href=#federated-graphql-anti-patterns>Federated GraphQL anti-patterns</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=api-composition-api-integration-aggregation--orchestration>API Composition: API Integration, Aggregation & Orchestration
<a class=anchor href=#api-composition-api-integration-aggregation--orchestration>#</a></h1><p>We use the term API composition to encompass three main aspects of working with multiple API endpoints:
integration, orchestration and aggregation.</p><p>A key driver for the Supergraph is the need for API composition. GraphQL (monolithic or federated) is a special case of this need.</p><p>While domain owners (producers) are owners of a domain API, in a multi-consumer & multi-producer scenario, API consumers often also need specialized APIs that are optimized for their use-cases.</p><p><img src=https://github.com/hasura/supergraph-io/assets/131160/53f3de0c-1f35-4032-a63d-9c2602566073 alt="Screen Shot 2024-05-13 at 10 22 07 PM"></p><p>This creates a tension between &ldquo;domain driven&rdquo; API design and ownership and &ldquo;consumer driven&rdquo; API design.</p><table><thead><tr><th>Design & Ownership</th><th>Benefits</th><th>Challenges</th></tr></thead><tbody><tr><td><strong>Domain driven</strong></td><td>Consistent, standardized API for multiple consumers</td><td>Not optimized for consumer needs</td></tr><tr><td><strong>Consumer driven</strong></td><td>Optimized for single consumer and can incorporate consumer specific business logic</td><td>Hard to standardize and needs to be purpose-built for every consumer</td></tr></tbody></table><p>A supergraph allows both these API design and ownership models to co-exist.
A supergraph platform brings in domain APIs via its subgraph connectors and provides a self-serve API orchestration & aggregation layer across the various domains. This allows domain owners to design and evolve their domain API, and other supergraph stakeholders to aggregate APIs on-demand and add custom orchestration workflows.</p><p>A supergraph platform solves the following 3 API composition problems:</p><ol><li>Integration</li><li>Aggregation</li><li>Orchestration</li></ol><h2 id=integration>Integration
<a class=anchor href=#integration>#</a></h2><p>Given that domains and domain APIs exist, API integration remains challenging for API consumers for the following reasons:</p><ol><li>The API output format or protocol is not ideal or optimal for a consumer</li><li>The API does not have a typed schema and/or does not provide a SDK experience for the consumer</li><li>The API&rsquo;s documentation is missing or out of date</li><li>The API does not have standardized conventions or follow a consistent design</li></ol><p>A supergraph provides a systematic way to address these challenges because it provides a common semantic layer and registry for the underlying domains and their APIs.
A well setup supergraph platform provides out of the box solutions for the challenges mentioned above.</p><h2 id=aggregation-or-batching>Aggregation (or batching)
<a class=anchor href=#aggregation-or-batching>#</a></h2><p>API consumers often need to fetch data from multiple API endpoints.
API aggregation or batching, performed closer to the domains can prevent excessive data transfer and prevent network round trips.</p><p>API aggregation is challenging because:</p><ol><li>Explosive creation of new aggregation API endpoints: Different consumers have different needs and their needs evolve rapidly in a high-velocity environment</li><li>Fuzzy ownership: Domain APIs are owned and designed by domain owners but often it is not clear who builds, designs and operates API endpoints that aggregate data across these endpoints</li></ol><p>A supergraph provides a self-service model for API aggregation and batching by modelling the underlying domains as a &ldquo;graph&rdquo; and then allowing API consumers to fetch whatever
slice of data they need from the on-demand without requiring the development and maintenance of new aggregate endpoints.</p><p>A well setup supergraph platform provides a high level of composability that makes different types of API aggregation possible on demand.
Eg:</p><ol><li>Joins: Fetch data from A and related data B</li><li>Nested filters: Fetch data from A, filtered by a property value of its related data B.</li></ol><h2 id=orchestration>Orchestration
<a class=anchor href=#orchestration>#</a></h2><p>API consumers often need to create reliable workflows that require sequencing multiple API calls interspersed with business logic.
Even if the underlying domain APIs exist, API orchestration is challenging because it is the part of the API that is consumer defined
and potentially spans multiple domains.</p><p>This makes it challenging to create a unified technology approach and identify owners to build and operate these workflows.</p><p>Related: Sagas, Distributed transactions, state machines.</p><p>A supergraph platform should provide a clear operating model and technology best practices to manage API orchestration, beyond
simple aggregation/batching use-cases.</p><h2 id=api-composition-checklist-for-a-supergraph-platform>API composition checklist for a supergraph platform
<a class=anchor href=#api-composition-checklist-for-a-supergraph-platform>#</a></h2><h2 id=federated-graphql-anti-patterns>Federated GraphQL anti-patterns
<a class=anchor href=#federated-graphql-anti-patterns>#</a></h2><p>Building a federated GraphQL API with a supergraph is a strategic decision.
When the key desired benefit of GraphQL is to solve an API composition problem on top of existing domains, then the key expected ROI is to improve API integration, aggregation and orchestration.
In this case, the following anti-patterns should be avoided. Building a federated GraphQL API with a supergraph is a strategic decision and the wrong choice can create thousands of person-hours of technical debt and legacy that become hard to unwind.</p><ol><li>❌ <strong>Pure schema-driven design</strong>:<ul><li>The situation: A schema driven in GraphQL is the approach of first building a schema that is entirely based on what consumers need.</li><li>The problem: While this approach is important for the parts of the API that require API aggregation and custom API orchestration workflows, this approach negates the effort that has gone into and the effort that will continue to go into maintaining domain APIs.</li><li>Symptoms: API producers are not willing to own their subgraphs and find it tedious to maintain another subgraph API. Additional subgraph teams and developers are required to maintain domain subgraphs.</li><li>The solution: Generating parts of the supergraph from the domain, and building parts of the supergraph based on consumer needs is the ideal approach.</li></ul></li><li>❌ <strong>Forcing subgraph owners to own inter-subgraph relationships</strong>:<ul><li>The situation: Relationships between subgraphs can only be specified by subgraph owners.</li><li>The problem: While this approach allows subgraph owners to extend and connect their subgraphs to other subgraphs, it requires domain owners (subgraph owners) to understand other subgraphs.</li><li>Symptoms: Disconnected supergraphs. Inefficient query execution plans if relationships are hard to implement in some directions. API consumers who are frustrated at not being able to participate in creating inter-subgraph relationships.</li><li>The solution: In addition to allowing subgraph owners to create inter-subgraph relationships, allow creation of relationships in the supergraph engine outside the subgraphs as well.</li></ul></li><li>❌ <strong>Requiring an additional API registry to create custom resolvers (eg: federated mutations)</strong>:<ul><li>The situation: Mutations can only originate from a domain subgraph.</li><li>The problem: Supergraph stakeholders are forced to create a new subgraph that directly connects to underlying domains. This requires stakeholders to refer to <em>another</em> API registry to understand how to connect to the underlying subgraph domains (eg: database, REST).</li><li>Symptoms: API consumers are frustrated at not being able to easily create custom resolvers that represent some unique business logic & workflow for their specific need. Lack of an operating model around federating mutations, or API sagas or distributed transactions.</li><li>The solution: The supergraph platform should provide a way for supergraph stakeholders to author custom API workflows interspersed with business logic without having to refer to APIs outside of the supergraph.</li></ul></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#integration>Integration</a></li><li><a href=#aggregation-or-batching>Aggregation (or batching)</a></li><li><a href=#orchestration>Orchestration</a></li><li><a href=#api-composition-checklist-for-a-supergraph-platform>API composition checklist for a supergraph platform</a></li><li><a href=#federated-graphql-anti-patterns>Federated GraphQL anti-patterns</a></li></ul></nav></div></aside></main></body></html>