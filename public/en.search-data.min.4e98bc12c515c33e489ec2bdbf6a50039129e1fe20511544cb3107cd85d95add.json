[{"id":0,"href":"/docs/articles/use-cases/","title":"Use Cases","section":"Articles","content":" Use Cases # The underlying problem that requires a supergraph: # Consuming data from multiple places requires integration or aggregation work This increases the burden on the producer since it takes time to build and is fragile The problem is combinatorially complex when there are multiple producers and multiple consumers Here are some common scenarios which point to the need of a supergraph: # You\u0026rsquo;re starting to evaluate the need of a federated data access layer API consumers wish they had a monolithic API view of their microservice APIs API consumers want GraphQL, but API producers don\u0026rsquo;t want to maintain GraphQL services You\u0026rsquo;re trying to add API integration or orchestration capabilities to your API gateway You\u0026rsquo;re thinking about API standardization for creating flexible data APIs You want to replace direct database access with APIs You want to deliver data products or a data mesh over an API You want to create a knowledge graph and enable data retrieval for AI applications In all of the situations above, the key problem is the lack of a strategy and an architecture to operationalize the strategy: # API consumers are frustrated by the lack of APIs that are optimized for their specific data retrieval use cases API producers are not willing to take on the burden of maintaining and operationalizing API aggregation and composition problems There is no operating model or ownership model for who should solve the integration problem "},{"id":1,"href":"/docs/use-cases/api-composition/","title":"API Composition","section":"Use Cases","content":" API Composition: API Integration, Aggregation \u0026amp; Orchestration # We use the term API composition to encompass three main aspects of working with multiple API endpoints: integration, orchestration and aggregation.\nA key driver for the Supergraph is the need for API composition. GraphQL (monolithic or federated) is a special case of this need.\nWhile domain owners (producers) are owners of a domain API, in a multi-consumer \u0026amp; multi-producer scenario, API consumers often also need specialized APIs that are optimized for their use-cases.\nThis creates a tension between \u0026ldquo;domain driven\u0026rdquo; API design and ownership and \u0026ldquo;consumer driven\u0026rdquo; API design.\nDesign \u0026amp; Ownership Benefits Challenges Domain driven Consistent, standardized API for multiple consumers Not optimized for consumer needs Consumer driven Optimized for single consumer and can incorporate consumer specific business logic Hard to standardize and needs to be purpose-built for every consumer A supergraph allows both these API design and ownership models to co-exist. A supergraph platform brings in domain APIs via its subgraph connectors and provides a self-serve API orchestration \u0026amp; aggregation layer across the various domains. This allows domain owners to design and evolve their domain API, and other supergraph stakeholders to aggregate APIs on-demand and add custom orchestration workflows.\nA supergraph platform solves the following 3 API composition problems:\nIntegration Aggregation Orchestration Integration # Given that domains and domain APIs exist, API integration remains challenging for API consumers for the following reasons:\nThe API output format or protocol is not ideal or optimal for a consumer The API does not have a typed schema and/or does not provide a SDK experience for the consumer The API\u0026rsquo;s documentation is missing or out of date The API does not have standardized conventions or follow a consistent design A supergraph provides a systematic way to address these challenges because it provides a common semantic layer and registry for the underlying domains and their APIs. A well setup supergraph platform provides out of the box solutions for the challenges mentioned above.\nAggregation (or batching) # API consumers often need to fetch data from multiple API endpoints. API aggregation or batching, performed closer to the domains can prevent excessive data transfer and prevent network round trips.\nAPI aggregation is challenging because:\nExplosive creation of new aggregation API endpoints: Different consumers have different needs and their needs evolve rapidly in a high-velocity environment Fuzzy ownership: Domain APIs are owned and designed by domain owners but often it is not clear who builds, designs and operates API endpoints that aggregate data across these endpoints A supergraph provides a self-service model for API aggregation and batching by modelling the underlying domains as a \u0026ldquo;graph\u0026rdquo; and then allowing API consumers to fetch whatever slice of data they need from the on-demand without requiring the development and maintenance of new aggregate endpoints.\nA well setup supergraph platform provides a high level of composability that makes different types of API aggregation possible on demand. Eg:\nJoins: Fetch data from A and related data B Nested filters: Fetch data from A, filtered by a property value of its related data B. Orchestration # API consumers often need to create reliable workflows that require sequencing multiple API calls interspersed with business logic. Even if the underlying domain APIs exist, API orchestration is challenging because it is the part of the API that is consumer defined and potentially spans multiple domains.\nThis makes it challenging to create a unified technology approach and identify owners to build and operate these workflows.\nRelated: Sagas, Distributed transactions, state machines.\nA supergraph platform should provide a clear operating model and technology best practices to manage API orchestration, beyond simple aggregation/batching use-cases.\nAPI composition checklist for a supergraph platform # Attribute Description 1. Integration Making it easy for API consumers to integrate APIs into their services 1.1 Multiple API formats Can the supergraph platform to automatically provide output formats beyond GraphQL? Eg: REST/OpenAPI This is required to prevent a lock in to the GraphQL protocol as needs change over time. 1.2 Documentation Does the supergraph platform help domain owners maintain documentation? If the underlying domain (database, code or APIs) are already documented, are those automatically picked up by the supergraph platform? 1.3 Standardization Does the supergraph platform provide or enforce a standardized domain API design? (Eg: pagination, filtering, sorting etc) 2. Aggregation Making it easy for API consumers to aggregate/batch multiple API calls into one 2.1 Relationships Does the supergraph provide a way of creating relationships between any 2 entities or endpoints without requiring changes from the domain owners 2.2 Composability How many \"join\" features does the supergraph provide, Given a relationship between 2 entities in the supergraph? 3. Orchestration Making it easy for supergraph stakeholders to author custom API orchestration 3.1 Federated mutations / decoupled orchestration business logic Does the supergraph provide a way to author orchestration flows within or across underlying domains? Federated GraphQL anti-patterns # Building a federated GraphQL API with a supergraph is a strategic decision. When the key desired benefit of GraphQL is to solve an API composition problem on top of existing domains, then the key expected ROI is to improve API integration, aggregation and orchestration. In this case, the following anti-patterns should be avoided. Building a federated GraphQL API with a supergraph is a strategic decision and the wrong choice can create thousands of person-hours of technical debt and legacy that become hard to unwind.\n❌ Pure schema-driven design: The situation: A schema driven in GraphQL is the approach of first building a schema that is entirely based on what consumers need. The problem: While this approach is important for the parts of the API that require API aggregation and custom API orchestration workflows, this approach negates the effort that has gone into and the effort that will continue to go into maintaining domain APIs. Symptoms: API producers are not willing to own their subgraphs and find it tedious to maintain another subgraph API. Additional subgraph teams and developers are required to maintain domain subgraphs. The solution: Generating parts of the supergraph from the domain, and building parts of the supergraph based on consumer needs is the ideal approach. ❌ Forcing subgraph owners to own inter-subgraph relationships: The situation: Relationships between subgraphs can only be specified by subgraph owners. The problem: While this approach allows subgraph owners to extend and connect their subgraphs to other subgraphs, it requires domain owners (subgraph owners) to understand other subgraphs. Symptoms: Disconnected supergraphs. Inefficient query execution plans if relationships are hard to implement in some directions. API consumers who are frustrated at not being able to participate in creating inter-subgraph relationships. The solution: In addition to allowing subgraph owners to create inter-subgraph relationships, allow creation of relationships in the supergraph engine outside the subgraphs as well. ❌ Requiring an additional API registry to create custom resolvers (eg: federated mutations): The situation: Mutations can only originate from a domain subgraph. The problem: Supergraph stakeholders are forced to create a new subgraph that directly connects to underlying domains. This requires stakeholders to refer to another API registry to understand how to connect to the underlying subgraph domains (eg: database, REST). Symptoms: API consumers are frustrated at not being able to easily create custom resolvers that represent some unique business logic \u0026amp; workflow for their specific need. Lack of an operating model around federating mutations, or API sagas or distributed transactions. The solution: The supergraph platform should provide a way for supergraph stakeholders to author custom API workflows interspersed with business logic without having to refer to APIs outside of the supergraph. "},{"id":2,"href":"/docs/references/faq/","title":"FAQ","section":"References","content":" FAQ # Supergraph vs alternative approaches # Connect domains Consume APIs Discover demand Technology Connector CI/CD Performance API Composability API portal Analytics Ecosystem integrations API gateway High N/A (no API aggregation features) Low Medium Medium Low IPaaS Low Low Medium Medium Medium Low Data virtualization Low Low - medium (usually designed for analytical workloads) High (usually only for non-API sources) Low (not API driven, usually SQL) N/A (no API analytics) Medium Supergraph Medium to High - depends on stack Medium to High - depends on stack Medium to High - depends on stack High High Depends on stack "}]