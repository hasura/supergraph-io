[{"id":0,"href":"/docs/full-reference-graphql-schema/","title":"Full Reference Graphql Schema","section":"Docs","content":" schema { query: query_root subscription: subscription_root } \u0026#34;\u0026#34;\u0026#34; Boolean expression to compare columns of type \u0026#34;Int\u0026#34;. All fields are combined with logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input Int_comparison_exp { _eq: Int _gt: Int _gte: Int _in: [Int!] _is_null: Boolean _lt: Int _lte: Int _neq: Int _nin: [Int!] } \u0026#34;\u0026#34;\u0026#34; Boolean expression to compare columns of type \u0026#34;String\u0026#34;. All fields are combined with logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input String_comparison_exp { _eq: String _gt: String _gte: String \u0026#34;\u0026#34;\u0026#34;does the column match the given case-insensitive pattern\u0026#34;\u0026#34;\u0026#34; _ilike: String _in: [String!] \u0026#34;\u0026#34;\u0026#34; does the column match the given POSIX regular expression, case insensitive \u0026#34;\u0026#34;\u0026#34; _iregex: String _is_null: Boolean \u0026#34;\u0026#34;\u0026#34;does the column match the given pattern\u0026#34;\u0026#34;\u0026#34; _like: String _lt: String _lte: String _neq: String \u0026#34;\u0026#34;\u0026#34;does the column NOT match the given case-insensitive pattern\u0026#34;\u0026#34;\u0026#34; _nilike: String _nin: [String!] \u0026#34;\u0026#34;\u0026#34; does the column NOT match the given POSIX regular expression, case insensitive \u0026#34;\u0026#34;\u0026#34; _niregex: String \u0026#34;\u0026#34;\u0026#34;does the column NOT match the given pattern\u0026#34;\u0026#34;\u0026#34; _nlike: String \u0026#34;\u0026#34;\u0026#34; does the column NOT match the given POSIX regular expression, case sensitive \u0026#34;\u0026#34;\u0026#34; _nregex: String \u0026#34;\u0026#34;\u0026#34;does the column NOT match the given SQL regular expression\u0026#34;\u0026#34;\u0026#34; _nsimilar: String \u0026#34;\u0026#34;\u0026#34; does the column match the given POSIX regular expression, case sensitive \u0026#34;\u0026#34;\u0026#34; _regex: String \u0026#34;\u0026#34;\u0026#34;does the column match the given SQL regular expression\u0026#34;\u0026#34;\u0026#34; _similar: String } \u0026#34;\u0026#34;\u0026#34; columns and relationships of \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; type article { \u0026#34;\u0026#34;\u0026#34;An object relationship\u0026#34;\u0026#34;\u0026#34; author: author! author_id: Int! id: Int! publishDate: date \u0026#34;\u0026#34;\u0026#34;An array relationship\u0026#34;\u0026#34;\u0026#34; ratings( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [rating_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [rating_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): [rating!]! \u0026#34;\u0026#34;\u0026#34;An aggregate relationship\u0026#34;\u0026#34;\u0026#34; ratings_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [rating_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [rating_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): rating_aggregate! title: String! } \u0026#34;\u0026#34;\u0026#34; aggregated selection of \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; type article_aggregate { aggregate: article_aggregate_fields nodes: [article!]! } input article_aggregate_bool_exp { count: article_aggregate_bool_exp_count } input article_aggregate_bool_exp_count { arguments: [article_select_column!] distinct: Boolean filter: article_bool_exp predicate: Int_comparison_exp! } \u0026#34;\u0026#34;\u0026#34; aggregate fields of \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; type article_aggregate_fields { avg: article_avg_fields count(columns: [article_select_column!], distinct: Boolean): Int! max: article_max_fields min: article_min_fields stddev: article_stddev_fields stddev_pop: article_stddev_pop_fields stddev_samp: article_stddev_samp_fields sum: article_sum_fields var_pop: article_var_pop_fields var_samp: article_var_samp_fields variance: article_variance_fields } \u0026#34;\u0026#34;\u0026#34; order by aggregate values of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_aggregate_order_by { avg: article_avg_order_by count: order_by max: article_max_order_by min: article_min_order_by stddev: article_stddev_order_by stddev_pop: article_stddev_pop_order_by stddev_samp: article_stddev_samp_order_by sum: article_sum_order_by var_pop: article_var_pop_order_by var_samp: article_var_samp_order_by variance: article_variance_order_by } \u0026#34;\u0026#34;\u0026#34;aggregate avg on columns\u0026#34;\u0026#34;\u0026#34; type article_avg_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by avg() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_avg_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34; Boolean expression to filter rows from the table \u0026#34;article\u0026#34;. All fields are combined with a logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input article_bool_exp { _and: [article_bool_exp!] _not: article_bool_exp _or: [article_bool_exp!] author: author_bool_exp author_id: Int_comparison_exp id: Int_comparison_exp publishDate: date_comparison_exp ratings: rating_bool_exp ratings_aggregate: rating_aggregate_bool_exp title: String_comparison_exp } \u0026#34;\u0026#34;\u0026#34;aggregate max on columns\u0026#34;\u0026#34;\u0026#34; type article_max_fields { author_id: Int id: Int publishDate: date title: String } \u0026#34;\u0026#34;\u0026#34; order by max() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_max_order_by { author_id: order_by id: order_by publishDate: order_by title: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate min on columns\u0026#34;\u0026#34;\u0026#34; type article_min_fields { author_id: Int id: Int publishDate: date title: String } \u0026#34;\u0026#34;\u0026#34; order by min() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_min_order_by { author_id: order_by id: order_by publishDate: order_by title: order_by } \u0026#34;\u0026#34;\u0026#34;Ordering options when selecting data from \u0026#34;article\u0026#34;.\u0026#34;\u0026#34;\u0026#34; input article_order_by { author: author_order_by author_id: order_by id: order_by publishDate: order_by ratings_aggregate: rating_aggregate_order_by title: order_by } \u0026#34;\u0026#34;\u0026#34; select columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; enum article_select_column { \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; author_id \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; id \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; publishDate \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; title } \u0026#34;\u0026#34;\u0026#34;aggregate stddev on columns\u0026#34;\u0026#34;\u0026#34; type article_stddev_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by stddev() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_stddev_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate stddev_pop on columns\u0026#34;\u0026#34;\u0026#34; type article_stddev_pop_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by stddev_pop() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_stddev_pop_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate stddev_samp on columns\u0026#34;\u0026#34;\u0026#34; type article_stddev_samp_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by stddev_samp() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_stddev_samp_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34; Streaming cursor of the table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_stream_cursor_input { \u0026#34;\u0026#34;\u0026#34;Stream column input with initial value\u0026#34;\u0026#34;\u0026#34; initial_value: article_stream_cursor_value_input! \u0026#34;\u0026#34;\u0026#34;cursor ordering\u0026#34;\u0026#34;\u0026#34; ordering: cursor_ordering } \u0026#34;\u0026#34;\u0026#34;Initial value of the column from where the streaming should start\u0026#34;\u0026#34;\u0026#34; input article_stream_cursor_value_input { author_id: Int id: Int publishDate: date title: String } \u0026#34;\u0026#34;\u0026#34;aggregate sum on columns\u0026#34;\u0026#34;\u0026#34; type article_sum_fields { author_id: Int id: Int } \u0026#34;\u0026#34;\u0026#34; order by sum() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_sum_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate var_pop on columns\u0026#34;\u0026#34;\u0026#34; type article_var_pop_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by var_pop() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_var_pop_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate var_samp on columns\u0026#34;\u0026#34;\u0026#34; type article_var_samp_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by var_samp() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_var_samp_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate variance on columns\u0026#34;\u0026#34;\u0026#34; type article_variance_fields { author_id: Float id: Float } \u0026#34;\u0026#34;\u0026#34; order by variance() on columns of table \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; input article_variance_order_by { author_id: order_by id: order_by } \u0026#34;\u0026#34;\u0026#34; columns and relationships of \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; type author { age: numeric \u0026#34;\u0026#34;\u0026#34;An array relationship\u0026#34;\u0026#34;\u0026#34; articles( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [article_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [article_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): [article!]! \u0026#34;\u0026#34;\u0026#34;An aggregate relationship\u0026#34;\u0026#34;\u0026#34; articles_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [article_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [article_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): article_aggregate! id: Int! name: String! } \u0026#34;\u0026#34;\u0026#34; aggregated selection of \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; type author_aggregate { aggregate: author_aggregate_fields nodes: [author!]! } \u0026#34;\u0026#34;\u0026#34; aggregate fields of \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; type author_aggregate_fields { avg: author_avg_fields count(columns: [author_select_column!], distinct: Boolean): Int! max: author_max_fields min: author_min_fields stddev: author_stddev_fields stddev_pop: author_stddev_pop_fields stddev_samp: author_stddev_samp_fields sum: author_sum_fields var_pop: author_var_pop_fields var_samp: author_var_samp_fields variance: author_variance_fields } \u0026#34;\u0026#34;\u0026#34;aggregate avg on columns\u0026#34;\u0026#34;\u0026#34; type author_avg_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34; Boolean expression to filter rows from the table \u0026#34;author\u0026#34;. All fields are combined with a logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input author_bool_exp { _and: [author_bool_exp!] _not: author_bool_exp _or: [author_bool_exp!] age: numeric_comparison_exp articles: article_bool_exp articles_aggregate: article_aggregate_bool_exp id: Int_comparison_exp name: String_comparison_exp } \u0026#34;\u0026#34;\u0026#34;aggregate max on columns\u0026#34;\u0026#34;\u0026#34; type author_max_fields { age: numeric id: Int name: String } \u0026#34;\u0026#34;\u0026#34;aggregate min on columns\u0026#34;\u0026#34;\u0026#34; type author_min_fields { age: numeric id: Int name: String } \u0026#34;\u0026#34;\u0026#34;Ordering options when selecting data from \u0026#34;author\u0026#34;.\u0026#34;\u0026#34;\u0026#34; input author_order_by { age: order_by articles_aggregate: article_aggregate_order_by id: order_by name: order_by } \u0026#34;\u0026#34;\u0026#34; select columns of table \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; enum author_select_column { \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; age \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; id \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; name } \u0026#34;\u0026#34;\u0026#34;aggregate stddev on columns\u0026#34;\u0026#34;\u0026#34; type author_stddev_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34;aggregate stddev_pop on columns\u0026#34;\u0026#34;\u0026#34; type author_stddev_pop_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34;aggregate stddev_samp on columns\u0026#34;\u0026#34;\u0026#34; type author_stddev_samp_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34; Streaming cursor of the table \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; input author_stream_cursor_input { \u0026#34;\u0026#34;\u0026#34;Stream column input with initial value\u0026#34;\u0026#34;\u0026#34; initial_value: author_stream_cursor_value_input! \u0026#34;\u0026#34;\u0026#34;cursor ordering\u0026#34;\u0026#34;\u0026#34; ordering: cursor_ordering } \u0026#34;\u0026#34;\u0026#34;Initial value of the column from where the streaming should start\u0026#34;\u0026#34;\u0026#34; input author_stream_cursor_value_input { age: numeric id: Int name: String } \u0026#34;\u0026#34;\u0026#34;aggregate sum on columns\u0026#34;\u0026#34;\u0026#34; type author_sum_fields { age: numeric id: Int } \u0026#34;\u0026#34;\u0026#34;aggregate var_pop on columns\u0026#34;\u0026#34;\u0026#34; type author_var_pop_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34;aggregate var_samp on columns\u0026#34;\u0026#34;\u0026#34; type author_var_samp_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34;aggregate variance on columns\u0026#34;\u0026#34;\u0026#34; type author_variance_fields { age: Float id: Float } \u0026#34;\u0026#34;\u0026#34;ordering argument of a cursor\u0026#34;\u0026#34;\u0026#34; enum cursor_ordering { \u0026#34;\u0026#34;\u0026#34;ascending ordering of the cursor\u0026#34;\u0026#34;\u0026#34; ASC \u0026#34;\u0026#34;\u0026#34;descending ordering of the cursor\u0026#34;\u0026#34;\u0026#34; DESC } scalar date \u0026#34;\u0026#34;\u0026#34; Boolean expression to compare columns of type \u0026#34;date\u0026#34;. All fields are combined with logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input date_comparison_exp { _eq: date _gt: date _gte: date _in: [date!] _is_null: Boolean _lt: date _lte: date _neq: date _nin: [date!] } scalar numeric \u0026#34;\u0026#34;\u0026#34; Boolean expression to compare columns of type \u0026#34;numeric\u0026#34;. All fields are combined with logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input numeric_comparison_exp { _eq: numeric _gt: numeric _gte: numeric _in: [numeric!] _is_null: Boolean _lt: numeric _lte: numeric _neq: numeric _nin: [numeric!] } \u0026#34;\u0026#34;\u0026#34;column ordering options\u0026#34;\u0026#34;\u0026#34; enum order_by { \u0026#34;\u0026#34;\u0026#34;in ascending order, nulls last\u0026#34;\u0026#34;\u0026#34; asc \u0026#34;\u0026#34;\u0026#34;in ascending order, nulls first\u0026#34;\u0026#34;\u0026#34; asc_nulls_first \u0026#34;\u0026#34;\u0026#34;in ascending order, nulls last\u0026#34;\u0026#34;\u0026#34; asc_nulls_last \u0026#34;\u0026#34;\u0026#34;in descending order, nulls first\u0026#34;\u0026#34;\u0026#34; desc \u0026#34;\u0026#34;\u0026#34;in descending order, nulls first\u0026#34;\u0026#34;\u0026#34; desc_nulls_first \u0026#34;\u0026#34;\u0026#34;in descending order, nulls last\u0026#34;\u0026#34;\u0026#34; desc_nulls_last } type query_root { \u0026#34;\u0026#34;\u0026#34; fetch data from the table: \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; article( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [article_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [article_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): [article!]! \u0026#34;\u0026#34;\u0026#34; fetch aggregated fields from the table: \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; article_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [article_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [article_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): article_aggregate! \u0026#34;\u0026#34;\u0026#34;fetch data from the table: \u0026#34;article\u0026#34; using primary key columns\u0026#34;\u0026#34;\u0026#34; article_by_pk(id: Int!): article \u0026#34;\u0026#34;\u0026#34; fetch data from the table: \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; author( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): [author!]! \u0026#34;\u0026#34;\u0026#34; fetch aggregated fields from the table: \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; author_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): author_aggregate! \u0026#34;\u0026#34;\u0026#34;fetch data from the table: \u0026#34;author\u0026#34; using primary key columns\u0026#34;\u0026#34;\u0026#34; author_by_pk(id: Int!): author \u0026#34;\u0026#34;\u0026#34; fetch data from the table: \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; rating( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [rating_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [rating_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): [rating!]! \u0026#34;\u0026#34;\u0026#34; fetch aggregated fields from the table: \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; rating_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [rating_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [rating_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): rating_aggregate! \u0026#34;\u0026#34;\u0026#34;fetch data from the table: \u0026#34;rating\u0026#34; using primary key columns\u0026#34;\u0026#34;\u0026#34; rating_by_pk(id: Int!): rating \u0026#34;\u0026#34;\u0026#34; execute function \u0026#34;search_authors\u0026#34; which returns \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; search_authors( \u0026#34;\u0026#34;\u0026#34; input parameters for function \u0026#34;search_authors\u0026#34; \u0026#34;\u0026#34;\u0026#34; args: search_authors_args! \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): [author!]! \u0026#34;\u0026#34;\u0026#34; execute function \u0026#34;search_authors\u0026#34; and query aggregates on result of table type \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; search_authors_aggregate( \u0026#34;\u0026#34;\u0026#34; input parameters for function \u0026#34;search_authors_aggregate\u0026#34; \u0026#34;\u0026#34;\u0026#34; args: search_authors_args! \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): author_aggregate! } \u0026#34;\u0026#34;\u0026#34; columns and relationships of \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; type rating { \u0026#34;\u0026#34;\u0026#34;An object relationship\u0026#34;\u0026#34;\u0026#34; article: article! article_id: Int! id: Int! stars: Int! user_id: Int! } \u0026#34;\u0026#34;\u0026#34; aggregated selection of \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; type rating_aggregate { aggregate: rating_aggregate_fields nodes: [rating!]! } input rating_aggregate_bool_exp { count: rating_aggregate_bool_exp_count } input rating_aggregate_bool_exp_count { arguments: [rating_select_column!] distinct: Boolean filter: rating_bool_exp predicate: Int_comparison_exp! } \u0026#34;\u0026#34;\u0026#34; aggregate fields of \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; type rating_aggregate_fields { avg: rating_avg_fields count(columns: [rating_select_column!], distinct: Boolean): Int! max: rating_max_fields min: rating_min_fields stddev: rating_stddev_fields stddev_pop: rating_stddev_pop_fields stddev_samp: rating_stddev_samp_fields sum: rating_sum_fields var_pop: rating_var_pop_fields var_samp: rating_var_samp_fields variance: rating_variance_fields } \u0026#34;\u0026#34;\u0026#34; order by aggregate values of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_aggregate_order_by { avg: rating_avg_order_by count: order_by max: rating_max_order_by min: rating_min_order_by stddev: rating_stddev_order_by stddev_pop: rating_stddev_pop_order_by stddev_samp: rating_stddev_samp_order_by sum: rating_sum_order_by var_pop: rating_var_pop_order_by var_samp: rating_var_samp_order_by variance: rating_variance_order_by } \u0026#34;\u0026#34;\u0026#34;aggregate avg on columns\u0026#34;\u0026#34;\u0026#34; type rating_avg_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by avg() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_avg_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34; Boolean expression to filter rows from the table \u0026#34;rating\u0026#34;. All fields are combined with a logical \u0026#39;AND\u0026#39;. \u0026#34;\u0026#34;\u0026#34; input rating_bool_exp { _and: [rating_bool_exp!] _not: rating_bool_exp _or: [rating_bool_exp!] article: article_bool_exp article_id: Int_comparison_exp id: Int_comparison_exp stars: Int_comparison_exp user_id: Int_comparison_exp } \u0026#34;\u0026#34;\u0026#34;aggregate max on columns\u0026#34;\u0026#34;\u0026#34; type rating_max_fields { article_id: Int id: Int stars: Int user_id: Int } \u0026#34;\u0026#34;\u0026#34; order by max() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_max_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate min on columns\u0026#34;\u0026#34;\u0026#34; type rating_min_fields { article_id: Int id: Int stars: Int user_id: Int } \u0026#34;\u0026#34;\u0026#34; order by min() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_min_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;Ordering options when selecting data from \u0026#34;rating\u0026#34;.\u0026#34;\u0026#34;\u0026#34; input rating_order_by { article: article_order_by article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34; select columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; enum rating_select_column { \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; article_id \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; id \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; stars \u0026#34;\u0026#34;\u0026#34;column name\u0026#34;\u0026#34;\u0026#34; user_id } \u0026#34;\u0026#34;\u0026#34;aggregate stddev on columns\u0026#34;\u0026#34;\u0026#34; type rating_stddev_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by stddev() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_stddev_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate stddev_pop on columns\u0026#34;\u0026#34;\u0026#34; type rating_stddev_pop_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by stddev_pop() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_stddev_pop_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate stddev_samp on columns\u0026#34;\u0026#34;\u0026#34; type rating_stddev_samp_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by stddev_samp() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_stddev_samp_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34; Streaming cursor of the table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_stream_cursor_input { \u0026#34;\u0026#34;\u0026#34;Stream column input with initial value\u0026#34;\u0026#34;\u0026#34; initial_value: rating_stream_cursor_value_input! \u0026#34;\u0026#34;\u0026#34;cursor ordering\u0026#34;\u0026#34;\u0026#34; ordering: cursor_ordering } \u0026#34;\u0026#34;\u0026#34;Initial value of the column from where the streaming should start\u0026#34;\u0026#34;\u0026#34; input rating_stream_cursor_value_input { article_id: Int id: Int stars: Int user_id: Int } \u0026#34;\u0026#34;\u0026#34;aggregate sum on columns\u0026#34;\u0026#34;\u0026#34; type rating_sum_fields { article_id: Int id: Int stars: Int user_id: Int } \u0026#34;\u0026#34;\u0026#34; order by sum() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_sum_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate var_pop on columns\u0026#34;\u0026#34;\u0026#34; type rating_var_pop_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by var_pop() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_var_pop_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate var_samp on columns\u0026#34;\u0026#34;\u0026#34; type rating_var_samp_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by var_samp() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_var_samp_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } \u0026#34;\u0026#34;\u0026#34;aggregate variance on columns\u0026#34;\u0026#34;\u0026#34; type rating_variance_fields { article_id: Float id: Float stars: Float user_id: Float } \u0026#34;\u0026#34;\u0026#34; order by variance() on columns of table \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; input rating_variance_order_by { article_id: order_by id: order_by stars: order_by user_id: order_by } input search_authors_args { search: String } type subscription_root { \u0026#34;\u0026#34;\u0026#34; fetch data from the table: \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; article( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [article_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [article_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): [article!]! \u0026#34;\u0026#34;\u0026#34; fetch aggregated fields from the table: \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; article_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [article_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [article_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): article_aggregate! \u0026#34;\u0026#34;\u0026#34;fetch data from the table: \u0026#34;article\u0026#34; using primary key columns\u0026#34;\u0026#34;\u0026#34; article_by_pk(id: Int!): article \u0026#34;\u0026#34;\u0026#34; fetch data from the table in a streaming manner: \u0026#34;article\u0026#34; \u0026#34;\u0026#34;\u0026#34; article_stream( \u0026#34;\u0026#34;\u0026#34;maximum number of rows returned in a single batch\u0026#34;\u0026#34;\u0026#34; batch_size: Int! \u0026#34;\u0026#34;\u0026#34;cursor to stream the results returned by the query\u0026#34;\u0026#34;\u0026#34; cursor: [article_stream_cursor_input]! \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: article_bool_exp ): [article!]! \u0026#34;\u0026#34;\u0026#34; fetch data from the table: \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; author( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): [author!]! \u0026#34;\u0026#34;\u0026#34; fetch aggregated fields from the table: \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; author_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): author_aggregate! \u0026#34;\u0026#34;\u0026#34;fetch data from the table: \u0026#34;author\u0026#34; using primary key columns\u0026#34;\u0026#34;\u0026#34; author_by_pk(id: Int!): author \u0026#34;\u0026#34;\u0026#34; fetch data from the table in a streaming manner: \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; author_stream( \u0026#34;\u0026#34;\u0026#34;maximum number of rows returned in a single batch\u0026#34;\u0026#34;\u0026#34; batch_size: Int! \u0026#34;\u0026#34;\u0026#34;cursor to stream the results returned by the query\u0026#34;\u0026#34;\u0026#34; cursor: [author_stream_cursor_input]! \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): [author!]! \u0026#34;\u0026#34;\u0026#34; fetch data from the table: \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; rating( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [rating_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [rating_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): [rating!]! \u0026#34;\u0026#34;\u0026#34; fetch aggregated fields from the table: \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; rating_aggregate( \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [rating_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [rating_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): rating_aggregate! \u0026#34;\u0026#34;\u0026#34;fetch data from the table: \u0026#34;rating\u0026#34; using primary key columns\u0026#34;\u0026#34;\u0026#34; rating_by_pk(id: Int!): rating \u0026#34;\u0026#34;\u0026#34; fetch data from the table in a streaming manner: \u0026#34;rating\u0026#34; \u0026#34;\u0026#34;\u0026#34; rating_stream( \u0026#34;\u0026#34;\u0026#34;maximum number of rows returned in a single batch\u0026#34;\u0026#34;\u0026#34; batch_size: Int! \u0026#34;\u0026#34;\u0026#34;cursor to stream the results returned by the query\u0026#34;\u0026#34;\u0026#34; cursor: [rating_stream_cursor_input]! \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: rating_bool_exp ): [rating!]! \u0026#34;\u0026#34;\u0026#34; execute function \u0026#34;search_authors\u0026#34; which returns \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; search_authors( \u0026#34;\u0026#34;\u0026#34; input parameters for function \u0026#34;search_authors\u0026#34; \u0026#34;\u0026#34;\u0026#34; args: search_authors_args! \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): [author!]! \u0026#34;\u0026#34;\u0026#34; execute function \u0026#34;search_authors\u0026#34; and query aggregates on result of table type \u0026#34;author\u0026#34; \u0026#34;\u0026#34;\u0026#34; search_authors_aggregate( \u0026#34;\u0026#34;\u0026#34; input parameters for function \u0026#34;search_authors_aggregate\u0026#34; \u0026#34;\u0026#34;\u0026#34; args: search_authors_args! \u0026#34;\u0026#34;\u0026#34;distinct select on columns\u0026#34;\u0026#34;\u0026#34; distinct_on: [author_select_column!] \u0026#34;\u0026#34;\u0026#34;limit the number of rows returned\u0026#34;\u0026#34;\u0026#34; limit: Int \u0026#34;\u0026#34;\u0026#34;skip the first n rows. Use only with order_by\u0026#34;\u0026#34;\u0026#34; offset: Int \u0026#34;\u0026#34;\u0026#34;sort the rows by one or more columns\u0026#34;\u0026#34;\u0026#34; order_by: [author_order_by!] \u0026#34;\u0026#34;\u0026#34;filter the rows returned\u0026#34;\u0026#34;\u0026#34; where: author_bool_exp ): author_aggregate! } "},{"id":1,"href":"/docs/use-cases/","title":"Use Cases","section":"Docs","content":" Use Cases # The underlying problem that requires a supergraph: # Consuming data from multiple places requires integration or aggregation work This increases the burden on the producer since it takes time to build and is fragile The problem is combinatorially complex when there are multiple producers and multiple consumers Here are some common scenarios which point to the need of a supergraph: # You\u0026rsquo;re starting to evaluate the need of a federated data access layer API consumers wish they had a monolithic API view of their microservice APIs API consumers want GraphQL, but API producers don\u0026rsquo;t want to maintain GraphQL services You\u0026rsquo;re trying to add API integration or orchestration capabilities to your API gateway You\u0026rsquo;re thinking about API standardization for creating flexible data APIs You want to replace direct database access with APIs You want to deliver data products or a data mesh over an API You want to create a knowledge graph and enable data retrieval for AI applications In all of the situations above, the key problem is the lack of a strategy and an architecture to operationalize the strategy: # API consumers are frustrated by the lack of APIs that are optimized for their specific data retrieval use cases API producers are not willing to take on the burden of maintaining and operationalizing API aggregation and composition problems There is no operating model or ownership model for who should solve the integration problem "},{"id":2,"href":"/docs/use-cases/api-composition/","title":"API Composition","section":"Docs","content":" API Composition: API Integration, Aggregation \u0026amp; Orchestration # We use the term API composition to encompass three main aspects of working with multiple API endpoints: integration, orchestration and aggregation.\nA key driver for the Supergraph is the need for API composition. GraphQL (monolithic or federated) is a special case of this need.\nWhile domain owners (producers) are owners of a domain API, in a multi-consumer \u0026amp; multi-producer scenario, API consumers often also need specialized APIs that are optimized for their use-cases.\nThis creates a tension between \u0026ldquo;domain driven\u0026rdquo; API design and ownership and \u0026ldquo;consumer driven\u0026rdquo; API design.\nDesign \u0026amp; Ownership Benefits Challenges Domain driven Consistent, standardized API for multiple consumers Not optimized for consumer needs Consumer driven Optimized for single consumer and can incorporate consumer specific business logic Hard to standardize and needs to be purpose-built for every consumer A supergraph allows both these API design and ownership models to co-exist. A supergraph platform brings in domain APIs via its subgraph connectors and provides a self-serve API orchestration \u0026amp; aggregation layer across the various domains. This allows domain owners to design and evolve their domain API, and other supergraph stakeholders to aggregate APIs on-demand and add custom orchestration workflows.\nA supergraph platform solves the following 3 API composition problems:\nIntegration Aggregation Orchestration Integration # Given that domains and domain APIs exist, API integration remains challenging for API consumers for the following reasons:\nThe API output format or protocol is not ideal or optimal for a consumer The API does not have a typed schema and/or does not provide a SDK experience for the consumer The API\u0026rsquo;s documentation is missing or out of date The API does not have standardized conventions or follow a consistent design A supergraph provides a systematic way to address these challenges because it provides a common semantic layer and registry for the underlying domains and their APIs. A well setup supergraph platform provides out of the box solutions for the challenges mentioned above.\nAggregation (or batching) # API consumers often need to fetch data from multiple API endpoints. API aggregation or batching, performed closer to the domains can prevent excessive data transfer and prevent network round trips.\nAPI aggregation is challenging because:\nExplosive creation of new aggregation API endpoints: Different consumers have different needs and their needs evolve rapidly in a high-velocity environment Fuzzy ownership: Domain APIs are owned and designed by domain owners but often it is not clear who builds, designs and operates API endpoints that aggregate data across these endpoints A supergraph provides a self-service model for API aggregation and batching by modelling the underlying domains as a \u0026ldquo;graph\u0026rdquo; and then allowing API consumers to fetch whatever slice of data they need from the on-demand without requiring the development and maintenance of new aggregate endpoints.\nA well setup supergraph platform provides a high level of composability that makes different types of API aggregation possible on demand. Eg:\nJoins: Fetch data from A and related data B Nested filters: Fetch data from A, filtered by a property value of its related data B. Orchestration # API consumers often need to create reliable workflows that require sequencing multiple API calls interspersed with business logic. Even if the underlying domain APIs exist, API orchestration is challenging because it is the part of the API that is consumer defined and potentially spans multiple domains.\nThis makes it challenging to create a unified technology approach and identify owners to build and operate these workflows.\nRelated: Sagas, Distributed transactions, state machines.\nA supergraph platform should provide a clear operating model and technology best practices to manage API orchestration, beyond simple aggregation/batching use-cases.\nAPI composition checklist for a supergraph platform # Federated GraphQL anti-patterns # Building a federated GraphQL API with a supergraph is a strategic decision. When the key desired benefit of GraphQL is to solve an API composition problem on top of existing domains, then the key expected ROI is to improve API integration, aggregation and orchestration. In this case, the following anti-patterns should be avoided. Building a federated GraphQL API with a supergraph is a strategic decision and the wrong choice can create thousands of person-hours of technical debt and legacy that become hard to unwind.\n❌ Pure schema-driven design: The situation: A schema driven in GraphQL is the approach of first building a schema that is entirely based on what consumers need. The problem: While this approach is important for the parts of the API that require API aggregation and custom API orchestration workflows, this approach negates the effort that has gone into and the effort that will continue to go into maintaining domain APIs. Symptoms: API producers are not willing to own their subgraphs and find it tedious to maintain another subgraph API. Additional subgraph teams and developers are required to maintain domain subgraphs. The solution: Generating parts of the supergraph from the domain, and building parts of the supergraph based on consumer needs is the ideal approach. ❌ Forcing subgraph owners to own inter-subgraph relationships: The situation: Relationships between subgraphs can only be specified by subgraph owners. The problem: While this approach allows subgraph owners to extend and connect their subgraphs to other subgraphs, it requires domain owners (subgraph owners) to understand other subgraphs. Symptoms: Disconnected supergraphs. Inefficient query execution plans if relationships are hard to implement in some directions. API consumers who are frustrated at not being able to participate in creating inter-subgraph relationships. The solution: In addition to allowing subgraph owners to create inter-subgraph relationships, allow creation of relationships in the supergraph engine outside the subgraphs as well. ❌ Requiring an additional API registry to create custom resolvers (eg: federated mutations): The situation: Mutations can only originate from a domain subgraph. The problem: Supergraph stakeholders are forced to create a new subgraph that directly connects to underlying domains. This requires stakeholders to refer to another API registry to understand how to connect to the underlying subgraph domains (eg: database, REST). Symptoms: API consumers are frustrated at not being able to easily create custom resolvers that represent some unique business logic \u0026amp; workflow for their specific need. Lack of an operating model around federating mutations, or API sagas or distributed transactions. The solution: The supergraph platform should provide a way for supergraph stakeholders to author custom API workflows interspersed with business logic without having to refer to APIs outside of the supergraph. "}]