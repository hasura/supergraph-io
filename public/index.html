<!doctype html><html lang=en-us dir=ltr><head><meta name=generator content="Hugo 0.127.0"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="The Supergraph Manifesto # Supergraph is an architecture framework that offers reference architectures, design guidelines/principles and an operating model to help multiple teams to collaborate on a self-serve platform for federated data access, API integration/composition or GraphQL APIs. An implementation artifact of the Supergraph architecture is called a supergraph (lowercase s).
When a supergraph is built with a GraphQL federation stack, the engine is often called a gateway or a router and the subgraph connectors are often GraphQL services."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/"><meta property="og:site_name" content="The Supergraph Manifesto"><meta property="og:title" content="The Supergraph Manifesto"><meta property="og:description" content="The Supergraph Manifesto # Supergraph is an architecture framework that offers reference architectures, design guidelines/principles and an operating model to help multiple teams to collaborate on a self-serve platform for federated data access, API integration/composition or GraphQL APIs. An implementation artifact of the Supergraph architecture is called a supergraph (lowercase s).
When a supergraph is built with a GraphQL federation stack, the engine is often called a gateway or a router and the subgraph connectors are often GraphQL services."><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><title>The Supergraph Manifesto | The Supergraph Manifesto</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=http://localhost:1313/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.2c8ab34126102d6821fc8b6a769187fd2df312c8a6555fee205abf003b26e18b.js integrity="sha256-LIqzQSYQLWgh/ItqdpGH/S3zEsimVV/uIFq/ADsm4Ys=" crossorigin=anonymous></script><link rel=alternate type=application/rss+xml href=http://localhost:1313/index.xml title="The Supergraph Manifesto"><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-TH6XP4D2")</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>The Supergraph Manifesto</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>Use Cases</span><ul><li><a href=/docs/use-cases/api-composition/>API Composition</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-7bdce2c0fc23441af69a437d2ef3eb12 class=toggle>
<label for=section-7bdce2c0fc23441af69a437d2ef3eb12 class="flex justify-between"><a role=button>Articles</a></label><ul><li><a href=/docs/articles/supergraph-in-disguise/>When should you supergraph?</a></li></ul></li><li class=book-section-flat><span>References</span><ul><li><a href=/docs/references/faq/>FAQ</a></li></ul></li></ul><ul><li><a href=https://github.com/hasura/supergraph-io target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>The Supergraph Manifesto</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#strategy-and-core-concepts>Strategy and Core concepts</a><ul><li><a href=#i-connect-domains>I. CONNECT domains</a></li><li><a href=#ii-consume-apis>II. CONSUME APIs</a></li><li><a href=#iii-discover-demand>III. DISCOVER demand</a></li></ul></li><li><a href=#architecture-guide>Architecture guide</a><ul><li><a href=#cicd-and-build-system-control-plane>CI/CD and build system (control plane)</a></li><li><a href=#distributed-data-plane>Distributed data plane</a></li></ul></li><li><a href=#api-schema-design-guide>API schema design guide</a><ul><li><a href=#standardization>Standardization</a></li><li><a href=#composability>Composability</a></li></ul></li><li><a href=#more-reading>More reading</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=the-supergraph-manifesto>The Supergraph Manifesto
<a class=anchor href=#the-supergraph-manifesto>#</a></h1><p>Supergraph is an architecture framework that offers reference architectures, design guidelines/principles and an operating model to help multiple teams to collaborate on a self-serve platform for federated data access, API integration/composition or GraphQL APIs. An implementation artifact of the Supergraph architecture is called a supergraph (<em>lowercase <code>s</code></em>).</p><p><img src=https://github.com/hasura/supergraph-io/assets/131160/2421b94e-724f-4e94-afee-61b2c81f38b7 alt="Before / After Supergraph"></p><p>When a supergraph is built with a GraphQL federation stack, the engine is often called a gateway or a router and the subgraph connectors are often GraphQL services.</p><p>A supergraph is typically used for the following 3 benefits:</p><ol><li><a href=/api-composition>Self-serve API composition</a>: A self-serve operating model for API integration, orchestration & aggregation</li><li>Federated data access layer: A federated data layer that allows realtime access to data sources with cross-domain composability (joins, filtering etc.) Related: Data mesh, data products</li><li>Incremental monolith decomposition: A stable API that provides a zero-downtime and incremental approach to decomposing monoliths</li></ol><h2 id=strategy-and-core-concepts>Strategy and Core concepts
<a class=anchor href=#strategy-and-core-concepts>#</a></h2><p>A supergraph approach aims to build a flywheel of data access and supply to incrementally improve self-service access to data and APIs.</p><img width=660 alt="Supergraph platform flywheel" src=https://github.com/hasura/supergraph-io/assets/131160/c6583319-55d8-4854-b593-1f6c1e6b3f05><h3 id=i-connect-domains>I. CONNECT domains
<a class=anchor href=#i-connect-domains>#</a></h3><p>Domain owners (or data owners, or API producers) should be able to seamlessly connect their domains to the platform. A major challenge in building supergraph is the resistance to change by the domain owners. They often oppose having to build, operate and maintain another API layer, such as a GraphQL server that creates another wrapper on their domain. This reluctance and concern is understandable and completely valid and must be systematically addressed by the supergraph platform strategy and the supergraph reference architecture.</p><p>This has two main implications for the subgraph connector&rsquo;s lifecycle and runtime:</p><ol><li><strong>Subgraph connector CI/CD</strong>: As domain owners change their domains, the API contract published via the supergraph engine, must stay in sync with the least amount of overhead for the domain owner. The SDLC, change-management or CI/CD process of the domain owners must involve updating their API contract (eg: versioning), prevent breaking changes and keeping documentation up to date.</li><li><strong>Subgraph connector performance</strong>: The subgraph connector must not <em>reduce</em> performance as compared to what is provided by accessing the underlying domain directly. API performance characteristics as measured by latency, payload size & concurrency.</li></ol><p>Guaranteeing a smooth CI/CD process and high-performance connectivity gives domain owners confidence that they can connect their domains to the supergraph platform and iterate on changes to their domains fearlessly.</p><p><strong>This unlocks self-serve connectivity for domain owners.</strong></p><h3 id=ii-consume-apis>II. CONSUME APIs
<a class=anchor href=#ii-consume-apis>#</a></h3><p>API consumers should be able to discover and consume APIs in a way that doesn&rsquo;t require manual API integration, aggregation or composition effort as far as possible.
API consumers have several common needs when they&rsquo;re dealing with fixed API endpoints or specific data queries:</p><ol><li>fetch different projections of data to prevent over-fetching</li><li>join data from multiple places to prevent under-fetching</li><li>filter, paginate, sort and aggregate data from multiple places</li></ol><p>To provide an API experience that makes the consumption experience truly self-serve, there are two key requirements:</p><ol><li><strong>Composable API design</strong>: The API presented by the supergraph engine must allow for on-demand composability. GraphQL is a great API to express composability semantics, but regardless of the API format used, a standardized, composable API design is a critical requirement.</li><li><strong>API portal</strong>: High-quality search, discovery and documentation of both the API and the underlying API models is critical to enable self-serve consumption. The more information that can be made available to API consumers the better. Eg: Data lineage, Authorization policies etc as appropriate.</li></ol><p><strong>This unlocks self-serve consumption for API consumers</strong></p><h3 id=iii-discover-demand>III. DISCOVER demand
<a class=anchor href=#iii-discover-demand>#</a></h3><p>Understanding how API consumers use their domain and identify their unmet needs is crucial for API producers. This insight allows API producers to enhance their domain. It also helps discover new domain owners to connect their domain into the supergraph.</p><p>This necessitates 2 key capabilities of the supergraph platform to create a consumer-first, agile culture:</p><ol><li>API consumption, API schema & portal analytics: A supergraph is analogous to a marketplace and needs to provide the marketplace owners and producers with insights to help improve the marketplace for the consumers.</li><li>Ecosystem integrations: The supergraph platform should be able to integrate with existing communication and catalog tools, in particular to help understand <em>unmet</em> demand of API consumers.</li></ol><p><strong>This closes the loop and allows the supergraph platform to create a virtuous cycle of success for producers and consumers</strong>.</p><h2 id=architecture-guide>Architecture guide
<a class=anchor href=#architecture-guide>#</a></h2><h3 id=cicd-and-build-system-control-plane>CI/CD and build system (control plane)
<a class=anchor href=#cicd-and-build-system-control-plane>#</a></h3><p>The control plane of the supergraph is critical to help domain owners
<a href=/#i.-connect-domains>connect their domains</a> to the supergraph.</p><p>There are 3 components in the control plane of the supergraph</p><ol><li>The domain itself</li><li>The subgraph</li><li>The supergraph</li></ol><img width=800 alt="Supergraph control plane components" src=https://github.com/hasura/supergraph-io/assets/131160/e661efd8-9d0f-4340-a5a1-a119e9fc87ee><p>The control plane should define the following SDLC to help keep the supergraph in sync with the domain as the underlying domain changes.</p><img width=800 alt="Supergraph CI/CD" src=https://github.com/hasura/supergraph-io/assets/131160/e6fec5a3-e3da-447e-9ac3-5dc0ceef66d9><h3 id=distributed-data-plane>Distributed data plane
<a class=anchor href=#distributed-data-plane>#</a></h3><p>The supergraph data plane is critical to enable high performance access to upstream domains so that API producers can maintain their domain without hidden future maintenance costs:</p><img width=800 alt="Supergraph data plane" src=https://github.com/hasura/supergraph-io/assets/131160/c6e1de9b-fe8f-4f9e-8503-7f655b02d9a9><h2 id=api-schema-design-guide>API schema design guide
<a class=anchor href=#api-schema-design-guide>#</a></h2><h3 id=standardization>Standardization
<a class=anchor href=#standardization>#</a></h3><p>A supergraph API schema should create standardized conventions on the following:</p><table><thead><tr><td class=fixed-col-width-1><b>Standardization Attribute</b></td><td><b>Capability</b></td></tr></thead><tbody><tr><td><b>S1</b></td><td>Separating models (resources) & commands (methods)
   <details><summary>Example</summary><ul><li>Models are collections of data that can be queried in standardized source-agnostic ways (eg: resources)</li><li>Commands are methods that map to particular pieces of business logic that might return references to other commands or models(eg: methods)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span>  <span style=color:#75715e># A standardized way to fetch a list of authors</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>query</span> <span style=color:#a6e22e>GetAuthors</span> {
</span></span><span style=display:flex><span>    authors {
</span></span><span style=display:flex><span>      id
</span></span><span style=display:flex><span>      name
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># A specific method to search for authors</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>query</span> <span style=color:#a6e22e>findAuthors</span> {
</span></span><span style=display:flex><span>    search_authors(args: {<span style=color:#a6e22e>search</span>: <span style=color:#e6db74>&#34;Einstein&#34;</span>}) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>id</span>
</span></span><span style=display:flex><span>      name
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div></details></td></tr><tr><td><b>S2</b></td><td>Model filtering<br><details><summary>Example</summary>Get a list of articles published this year<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span> <span style=color:#66d9ef>query</span> <span style=color:#a6e22e>articlesThisYear</span> {
</span></span><span style=display:flex><span>    articles(where: {<span style=color:#a6e22e>publishDate</span>: {<span style=color:#a6e22e>_gt</span>: <span style=color:#e6db74>&#34;2024-01-01&#34;</span>}}) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>id</span>
</span></span><span style=display:flex><span>      name
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div></details></td></tr><tr><td><b>S3</b></td><td>Model sorting<details><summary>Example</summary>Get a list of articles sorted in reverse by the date of publishing<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span> <span style=color:#a6e22e>sortedArticles</span> {
</span></span><span style=display:flex><span>  article(order_by: {<span style=color:#a6e22e>publishDate</span>: <span style=color:#a6e22e>desc</span>}) {
</span></span><span style=display:flex><span>    id
</span></span><span style=display:flex><span>    title
</span></span><span style=display:flex><span>    author_id
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></details></td></tr><tr><td><b>S4</b></td><td>Model pagination<details><summary>Example</summary>Paginate the above list with 20 objects per page and fetch the 3rd page<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span> <span style=color:#a6e22e>sortedArticlesThirdPage</span> {
</span></span><span style=display:flex><span>  article(order_by: {<span style=color:#a6e22e>publishDate</span>: <span style=color:#a6e22e>desc</span>}, offset: <span style=color:#a6e22e>40</span>, limit: <span style=color:#a6e22e>20</span>) {
</span></span><span style=display:flex><span>    id
</span></span><span style=display:flex><span>    title
</span></span><span style=display:flex><span>    author_id
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></details></td></tr><tr><td><b>S5</b></td><td>Model aggregations over fields<details><summary>Example</summary>Get a count of authors and their average age<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span> <span style=color:#a6e22e>authorStatistics</span> {
</span></span><span style=display:flex><span>  author_aggregate {
</span></span><span style=display:flex><span>    aggregate {
</span></span><span style=display:flex><span>      count <span style=color:#75715e># basic aggregation support by any model</span>
</span></span><span style=display:flex><span>      avg { <span style=color:#75715e># supported over any numeric fields of a type</span>
</span></span><span style=display:flex><span>        age
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></details></td></tr></tbody></table><p><strong>Prior art</strong></p><ul><li><a href=https://cloud.google.com/apis/design/resources>Google Cloud API design guide</a><ul><li>Resource: A resource-oriented API is generally modeled as a resource hierarchy, where each node is either a simple resource or a collection resource</li><li>Method: Resources are manipulated via a small set of methods</li></ul></li></ul><h3 id=composability>Composability
<a class=anchor href=#composability>#</a></h3><p>The supergraph API is typically a GraphQL / JSON API. There are varying degrees of composability an API can offer, as listed out in the following table:</p><table><thead><tr><td class=fixed-col-width-1><b>Composability Attribute</b></td><td class=fixed-col-width-2><b>Capability</b></td><td><b>Description</b></td></tr></thead><tr><tbody><td><b>C1</b></td><td>Joining data</td><td>Join related data together in a "foreign key" like join<details><summary>Example</summary>Get a list of authors and <b>their</b> articles<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span> <span style=color:#a6e22e>authorWithArticles</span> {
</span></span><span style=display:flex><span>  author {
</span></span><span style=display:flex><span>    id
</span></span><span style=display:flex><span>    name
</span></span><span style=display:flex><span>    articles {
</span></span><span style=display:flex><span>      id
</span></span><span style=display:flex><span>      title
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></details></td></tr><tr><td><b>C2</b></td><td>Nested filtering</td><td>Filter a parent by a property of its child (i.e. a property of a related entity)<details><summary>Example</summary>Get a list of authors whose have published an article this year<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span> <span style=color:#a6e22e>recentlyActiveAuthors</span> {
</span></span><span style=display:flex><span>  author(where: {<span style=color:#a6e22e>articles</span>: {<span style=color:#a6e22e>publishDate</span>: {<span style=color:#a6e22e>_gt</span>: <span style=color:#e6db74>&#34;2024-01-01&#34;</span>}}}) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>id</span>
</span></span><span style=display:flex><span>    name
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></details></td></tr><tr><td><b>C3</b></td><td>Nested sorting</td><td>Sort a parent by a property of its child (i.e. a property of a related entity)<details><summary>Example</summary>Get a list of articles sorted by the names of their author<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span> <span style=color:#a6e22e>sortedArticles</span> {
</span></span><span style=display:flex><span>  article(order_by: {<span style=color:#a6e22e>author</span>: {<span style=color:#a6e22e>name</span>: <span style=color:#a6e22e>asc</span>}}) {
</span></span><span style=display:flex><span>    id
</span></span><span style=display:flex><span>    title
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></details></td></tr><tr><td><b>C4</b></td><td>Nested pagination</td><td>Fetch a paginated list of parents, along with a paginated & sorted list of children for each parent<details><summary>Example</summary>Get the 2nd page of a list of authors and the first page of <b>their</b> articles, sorted by the article's title field<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span> <span style=color:#a6e22e>paginatedAuthorsWithSortedPaginatedArticles</span> {
</span></span><span style=display:flex><span>  author(offset: <span style=color:#a6e22e>10</span>, limit: <span style=color:#a6e22e>20</span>) {
</span></span><span style=display:flex><span>    id
</span></span><span style=display:flex><span>    name
</span></span><span style=display:flex><span>    articles(offset: <span style=color:#a6e22e>0</span>, limit: <span style=color:#a6e22e>25</span>, order_by: {<span style=color:#a6e22e>title</span>: <span style=color:#a6e22e>asc</span>}) {
</span></span><span style=display:flex><span>      title
</span></span><span style=display:flex><span>      publishDate
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></details></td></tr><tr><td><b>C5</b></td><td>Nested aggregation</td><td>Aggregate a child/parent in the context of its parent/child<details><summary>Example</summary>Get a list of authors and the number of articles written by each author<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span> <span style=color:#a6e22e>prolificAuthors</span> {
</span></span><span style=display:flex><span>  author (limit: <span style=color:#a6e22e>10</span>) {
</span></span><span style=display:flex><span>    id
</span></span><span style=display:flex><span>    name
</span></span><span style=display:flex><span>    articles_aggregate {
</span></span><span style=display:flex><span>      count
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></details></td></tr></tbody></table><p>These composability attributes are what increase the level of self-serve composition and reduce the need for manual API aggregation and composition.</p><h2 id=more-reading>More reading
<a class=anchor href=#more-reading>#</a></h2><ul><li><a href=/use-cases>Use cases</a></li><li><a href=/reference-api-schema>Reference API schema</a></li><li><a href=/faq>FAQ</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/_index.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#strategy-and-core-concepts>Strategy and Core concepts</a><ul><li><a href=#i-connect-domains>I. CONNECT domains</a></li><li><a href=#ii-consume-apis>II. CONSUME APIs</a></li><li><a href=#iii-discover-demand>III. DISCOVER demand</a></li></ul></li><li><a href=#architecture-guide>Architecture guide</a><ul><li><a href=#cicd-and-build-system-control-plane>CI/CD and build system (control plane)</a></li><li><a href=#distributed-data-plane>Distributed data plane</a></li></ul></li><li><a href=#api-schema-design-guide>API schema design guide</a><ul><li><a href=#standardization>Standardization</a></li><li><a href=#composability>Composability</a></li></ul></li><li><a href=#more-reading>More reading</a></li></ul></nav></div></aside></main><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TH6XP4D2" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript></body></html>