<!doctype html><html lang=en-us dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Federated Data Access Layer # A federated data access layer is a data access layer that allows access to multiple, independently governed data sources.
A low-latency federated realtime data access layer provides a unified backbone for products & microservices at the experience layer. A federated data access layer is the delivery or service layer for a data-mesh or for data products.
There are 2 key dimensions
Federated ownership API formats Types of data sources Business logic We use the term API composition to encompass three main aspects of working with multiple API endpoints: integration, orchestration and aggregation."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/docs/use-cases/federated-data-layer/"><meta property="og:site_name" content="The Supergraph Manifesto"><meta property="og:title" content="Federated Data Access Layer"><meta property="og:description" content="Federated Data Access Layer # A federated data access layer is a data access layer that allows access to multiple, independently governed data sources.
A low-latency federated realtime data access layer provides a unified backbone for products & microservices at the experience layer. A federated data access layer is the delivery or service layer for a data-mesh or for data products.
There are 2 key dimensions
Federated ownership API formats Types of data sources Business logic We use the term API composition to encompass three main aspects of working with multiple API endpoints: integration, orchestration and aggregation."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Federated Data Access Layer | The Supergraph Manifesto</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=http://localhost:1313/docs/use-cases/federated-data-layer/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.2c8ab34126102d6821fc8b6a769187fd2df312c8a6555fee205abf003b26e18b.js integrity="sha256-LIqzQSYQLWgh/ItqdpGH/S3zEsimVV/uIFq/ADsm4Ys=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>The Supergraph Manifesto</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>Use Cases</span><ul><li><a href=/docs/use-cases/api-composition/>API Composition</a></li><li><a href=/docs/use-cases/federated-data-layer/ class=active>Federated Data Access Layer</a></li></ul></li><li class=book-section-flat><input type=checkbox id=section-7bdce2c0fc23441af69a437d2ef3eb12 class=toggle>
<label for=section-7bdce2c0fc23441af69a437d2ef3eb12 class="flex justify-between"><a role=button>Articles</a></label><ul><li><a href=/docs/articles/supergraph-in-disguise/>When should you supergraph?</a></li></ul></li><li class=book-section-flat><span>References</span><ul><li><a href=/docs/references/faq/>FAQ</a></li></ul></li></ul><ul><li><a href=https://github.com/hasura/supergraph-io target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Federated Data Access Layer</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#integration>Integration</a></li><li><a href=#aggregation-or-batching>Aggregation (or batching)</a></li><li><a href=#orchestration>Orchestration</a></li><li><a href=#api-composition-checklist>API composition checklist</a></li><li><a href=#federated-graphql-anti-patterns>Federated GraphQL anti-patterns</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=federated-data-access-layer>Federated Data Access Layer
<a class=anchor href=#federated-data-access-layer>#</a></h1><p>A federated data access layer is a data access layer that allows access to multiple, independently governed data sources.</p><p>A low-latency federated realtime data access layer provides a unified backbone for products & microservices at the experience layer.
A federated data access layer is the delivery or service layer for a data-mesh or for data products.</p><p>There are 2 key dimensions</p><ul><li>Federated ownership</li><li>API formats</li><li>Types of data sources</li><li>Business logic</li></ul><p>We use the term API composition to encompass three main aspects of working with multiple API endpoints:
integration, orchestration and aggregation.</p><p>A key driver for the Supergraph is the need for API composition. GraphQL (monolithic or federated) is a special case of this need.</p><p>While domain owners (producers) are owners of a domain API, in a multi-consumer & multi-producer scenario, API consumers often also need specialized APIs that are optimized for their use-cases.</p><p><img src=https://github.com/hasura/supergraph-io/assets/131160/53f3de0c-1f35-4032-a63d-9c2602566073 alt="Screen Shot 2024-05-13 at 10 22 07 PM"></p><p>This creates a tension between &ldquo;domain driven&rdquo; API design and ownership and &ldquo;consumer driven&rdquo; API design.</p><table><thead><tr><th>Design & Ownership</th><th>Benefits</th><th>Challenges</th></tr></thead><tbody><tr><td><strong>Domain driven</strong></td><td>Consistent, standardized API for multiple consumers</td><td>Not optimized for consumer needs</td></tr><tr><td><strong>Consumer driven</strong></td><td>Optimized for single consumer and can incorporate consumer specific business logic</td><td>Hard to standardize and needs to be purpose-built for every consumer</td></tr></tbody></table><p>A supergraph allows both these API design and ownership models to co-exist.
A supergraph platform brings in domain APIs via its subgraph connectors and provides a self-serve API orchestration & aggregation layer across the various domains. This allows domain owners to design and evolve their domain API, and other supergraph stakeholders to aggregate APIs on-demand and add custom orchestration workflows.</p><p>A supergraph platform solves the following 3 API composition problems:</p><ol><li>Integration</li><li>Aggregation</li><li>Orchestration</li></ol><h2 id=integration>Integration
<a class=anchor href=#integration>#</a></h2><p>Given that domains and domain APIs exist, API integration remains challenging for API consumers for the following reasons:</p><ol><li>The API output format or protocol is not ideal or optimal for a consumer</li><li>The API does not have a typed schema and/or does not provide a SDK experience for the consumer</li><li>The API&rsquo;s documentation is missing or out of date</li><li>The API does not have standardized conventions or follow a consistent design</li></ol><p>A supergraph provides a systematic way to address these challenges because it provides a common semantic layer and registry for the underlying domains and their APIs.
A well setup supergraph platform provides out of the box solutions for the challenges mentioned above.</p><h2 id=aggregation-or-batching>Aggregation (or batching)
<a class=anchor href=#aggregation-or-batching>#</a></h2><p>API consumers often need to fetch data from multiple API endpoints.
API aggregation or batching, performed closer to the domains can prevent excessive data transfer and prevent network round trips.</p><p>API aggregation is challenging because:</p><ol><li>Explosive creation of new aggregation API endpoints: Different consumers have different needs and their needs evolve rapidly in a high-velocity environment</li><li>Fuzzy ownership: Domain APIs are owned and designed by domain owners but often it is not clear who builds, designs and operates API endpoints that aggregate data across these endpoints</li></ol><p>A supergraph provides a self-service model for API aggregation and batching by modelling the underlying domains as a &ldquo;graph&rdquo; and then allowing API consumers to fetch whatever
slice of data they need from the on-demand without requiring the development and maintenance of new aggregate endpoints.</p><p>A well setup supergraph platform provides a high level of composability that makes different types of API aggregation possible on demand.
Eg:</p><ol><li>Joins: Fetch data from A and related data B</li><li>Nested filters: Fetch data from A, filtered by a property value of its related data B.</li></ol><h2 id=orchestration>Orchestration
<a class=anchor href=#orchestration>#</a></h2><p>API consumers often need to create reliable workflows that require sequencing multiple API calls interspersed with business logic.
Even if the underlying domain APIs exist, API orchestration is challenging because it is the part of the API that is consumer defined
and potentially spans multiple domains.</p><p>This makes it challenging to create a unified technology approach and identify owners to build and operate these workflows.</p><p>Related: Sagas, Distributed transactions, state machines.</p><p>A supergraph platform should provide a clear operating model and technology best practices to manage API orchestration, beyond
simple aggregation/batching use-cases.</p><h2 id=api-composition-checklist>API composition checklist
<a class=anchor href=#api-composition-checklist>#</a></h2><table><tbody><tr><td><b>1. Integration</b></td><td><b>Making it easy for API consumers to integrate APIs into their services</b></td></tr><tr><td>1.1 Multiple API formats</td><td><ul><li>Can the supergraph platform to automatically provide output formats beyond GraphQL? Eg: REST/OpenAPI, gRPC.</li></ul>This is required to prevent a lock in to the GraphQL protocol as needs change over time.</tr><tr><td>1.2 Documentation</td><td><ul><li>Does the supergraph platform help domain owners maintain documentation?</li><li>If the underlying domain (database, code or APIs) are already documented, are those automatically picked up by the supergraph platform?</li></ul></td></tr><tr><td>1.3 Standardization</td><td><ul><li>Does the supergraph platform provide or enforce a standardized domain API design? (Eg: pagination, filtering, sorting etc)</li></ul></td></tr><tr><td><b>2. Aggregation</b></td><td><b>Making it easy for API consumers to aggregate/batch multiple API calls into one</b></td></tr><tr><td>2.1 Relationships</td><td><ul><li>Does the supergraph provide a way of creating relationships between any 2 entities or endpoints without requiring changes from the domain owners</li></ul></td></tr><tr><td>2.2 Composability</td><td><ul><li>How many "join" features does the supergraph provide, given a relationship between 2 entities in the supergraph? <a href=/#composability>Examples</a></li></ul></td></tr><tr><td><b>3. Orchestration</b></td><td><b>Making it easy for supergraph stakeholders to author custom API orchestration</b></td></tr><tr><td>3.1 Custom orchestration business logic</td><td><ul><li>Does the supergraph provide a way to author orchestration flows within or across underlying domains?</li></ul></td></tr></tbody></table><h2 id=federated-graphql-anti-patterns>Federated GraphQL anti-patterns
<a class=anchor href=#federated-graphql-anti-patterns>#</a></h2><p>Building a federated GraphQL API with a supergraph is a strategic decision.
When the key desired benefit of GraphQL is to solve an API composition problem on top of existing domains, then the key expected ROI is to improve API integration, aggregation and orchestration.
In this case, the following anti-patterns should be avoided. Building a federated GraphQL API with a supergraph is a strategic decision and the wrong choice can create thousands of person-hours of technical debt and legacy that become hard to unwind.</p><ol><li>❌ <strong>Pure schema-driven design</strong>:<ul><li>The situation: A schema driven in GraphQL is the approach of first building a schema that is entirely based on what consumers need.</li><li>The problem: While this approach is important for the parts of the API that require API aggregation and custom API orchestration workflows, this approach negates the effort that has gone into and the effort that will continue to go into maintaining domain APIs.</li><li>Symptoms: API producers are not willing to own their subgraphs and find it tedious to maintain another subgraph API. Additional subgraph teams and developers are required to maintain domain subgraphs.</li><li>The solution: Generating parts of the supergraph from the domain, and building parts of the supergraph based on consumer needs is the ideal approach.</li></ul></li><li>❌ <strong>Forcing subgraph owners to own inter-subgraph relationships</strong>:<ul><li>The situation: Relationships between subgraphs can only be specified by subgraph owners.</li><li>The problem: While this approach allows subgraph owners to extend and connect their subgraphs to other subgraphs, it requires domain owners (subgraph owners) to understand other subgraphs.</li><li>Symptoms: Disconnected supergraphs. Inefficient query execution plans if relationships are hard to implement in some directions. API consumers who are frustrated at not being able to participate in creating inter-subgraph relationships.</li><li>The solution: In addition to allowing subgraph owners to create inter-subgraph relationships, allow creation of relationships in the supergraph engine outside the subgraphs as well.</li></ul></li><li>❌ <strong>Requiring an additional API registry to create custom resolvers (eg: federated mutations)</strong>:<ul><li>The situation: Mutations can only originate from a domain subgraph.</li><li>The problem: Supergraph stakeholders are forced to create a new subgraph that directly connects to underlying domains. This requires stakeholders to refer to <em>another</em> API registry to understand how to connect to the underlying subgraph domains (eg: database, REST).</li><li>Symptoms: API consumers are frustrated at not being able to easily create custom resolvers that represent some unique business logic & workflow for their specific need. Lack of an operating model around federating mutations, or API sagas or distributed transactions.</li><li>The solution: The supergraph platform should provide a way for supergraph stakeholders to author custom API workflows interspersed with business logic without having to refer to APIs outside of the supergraph.</li></ul></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/docs/use-cases/federated-data-layer.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#integration>Integration</a></li><li><a href=#aggregation-or-batching>Aggregation (or batching)</a></li><li><a href=#orchestration>Orchestration</a></li><li><a href=#api-composition-checklist>API composition checklist</a></li><li><a href=#federated-graphql-anti-patterns>Federated GraphQL anti-patterns</a></li></ul></nav></div></aside></main></body></html>